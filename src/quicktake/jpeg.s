;
; File generated by cc65 v 2.19 - Git 54a2410b5
;
	.fopt		compiler,"cc65 v 2.19 - Git 54a2410b5"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	c_sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_printf
	.import		_read
	.import		_lseek
	.import		_progress_bar
	.importzp	_prev_ram_irq_vector
	.importzp	_zp8
	.importzp	_zp2i
	.import		_cache
	.export		_cache_start
	.import		_cache_end
	.import		_ifd
	.import		_height
	.export		_raw_image
	.export		_magic
	.export		_model
	.export		_huff_ptr
	.export		_qt_load_raw
	.export		_pjpeg_decode_init
	.import		_pjpeg_decode_mcu
	.export		_gCoeffBuf
	.export		_gRestartInterval
	.export		_gRestartsLeft
	.export		_gMaxBlocksPerMCU
	.export		_gCompsInFrame
	.export		_gCompIdent
	.export		_gCompHSamp
	.export		_gCompVSamp
	.export		_gCompQuant
	.export		_gNextRestartNum
	.export		_gCompsInScan
	.export		_gCompList
	.export		_gCompDCTab
	.export		_gCompACTab
	.import		_gHuffTab0
	.import		_gHuffVal0
	.import		_gHuffTab1
	.import		_gHuffVal1
	.import		_gHuffTab2
	.import		_gHuffVal2
	.import		_gHuffTab3
	.import		_gHuffVal3
	.import		_gQuant0_l
	.import		_gQuant0_h
	.import		_gQuant1_l
	.import		_gQuant1_h
	.export		_gLastDC_l
	.export		_gLastDC_h
	.export		_gNumMCUSRemainingX
	.export		_gNumMCUSRemainingY
	.export		_gMCUOrg
	.import		_initFloppyStarter
	.import		_getBitsNoFF
	.import		_getBitsFF
	.export		_fillInBuf
	.export		_processRestart
	.export		_skipVariableMarker
	.import		_copy_decoded_to
	.import		_createWinogradQuant0
	.import		_createWinogradQuant1

.segment	"DATA"

_magic:
	.byte	$FF,$D8,$FF,$E1,$00
_model:
	.addr	S0041
_cache_start:
	.addr	_cache+4
_mcu_x:
	.byte	$00

.segment	"RODATA"

S0049:
	.byte	$50,$72,$6F,$67,$72,$65,$73,$73,$69,$76,$65,$20,$4A,$50,$45,$47
	.byte	$20,$66,$69,$6C,$65,$73,$20,$61,$72,$65,$20,$6E,$6F,$74,$20,$73
	.byte	$75,$70,$70,$6F,$72,$74,$65,$64,$2E,$0A,$00
S0048:
	.byte	$70,$6A,$70,$65,$67,$5F,$64,$65,$63,$6F,$64,$65,$5F,$69,$6E,$69
	.byte	$74,$28,$29,$20,$66,$61,$69,$6C,$65,$64,$20,$77,$69,$74,$68,$20
	.byte	$73,$74,$61,$74,$75,$73,$20,$25,$75,$0A,$00
S004A:
	.byte	$70,$6A,$70,$65,$67,$5F,$64,$65,$63,$6F,$64,$65,$5F,$6D,$63,$75
	.byte	$28,$29,$20,$66,$61,$69,$6C,$65,$64,$20,$77,$69,$74,$68,$20,$73
	.byte	$74,$61,$74,$75,$73,$20,$25,$75,$0A,$00
S0041:
	.byte	$32,$30,$30,$00

.segment	"BSS"

_raw_image:
	.res	12800,$00
_huff_ptr:
	.res	2,$00
_gCoeffBuf:
	.res	128,$00
_gRestartInterval:
	.res	2,$00
_gRestartsLeft:
	.res	2,$00
_gMaxBlocksPerMCU:
	.res	1,$00
_gCompsInFrame:
	.res	1,$00
_gCompIdent:
	.res	3,$00
_gCompHSamp:
	.res	3,$00
_gCompVSamp:
	.res	3,$00
_gCompQuant:
	.res	3,$00
_gNextRestartNum:
	.res	2,$00
_gCompsInScan:
	.res	1,$00
_gCompList:
	.res	3,$00
_gCompDCTab:
	.res	3,$00
_gCompACTab:
	.res	3,$00
_gLastDC_l:
	.res	3,$00
_gLastDC_h:
	.res	3,$00
_gNumMCUSRemainingX:
	.res	1,$00
_gNumMCUSRemainingY:
	.res	1,$00
_gMCUOrg:
	.res	6,$00
_gValidQuantTables:
	.res	1,$00
_gTemFlag:
	.res	1,$00
_status:
	.res	1,$00
_dst_y:
	.res	2,$00

; ---------------------------------------------------------------
; void __near__ qt_load_raw (unsigned int top)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_qt_load_raw: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; if (top == 0) {
;
	ldy     #$00
	lda     (c_sp),y
	iny
	ora     (c_sp),y
	bne     L0002
;
; initFloppyStarter();
;
	jsr     _initFloppyStarter
;
; status = pjpeg_decode_init();
;
	jsr     _pjpeg_decode_init
	sta     _status
;
; if (status) {
;
	lda     _status
	beq     L0004
;
; printf("pjpeg_decode_init() failed with status %u\n", status);
;
	lda     #<(S0048)
	ldx     #>(S0048)
	jsr     pushax
	lda     _status
	jsr     pusha0
	ldy     #$04
	jsr     _printf
;
; if (status == PJPG_UNSUPPORTED_MODE) {
;
	lda     _status
	cmp     #$27
	jne     L0007
;
; printf("Progressive JPEG files are not supported.\n");
;
	lda     #<(S0049)
	ldx     #>(S0049)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; return;
;
	jmp     incsp2
;
; dst_y = 0;
;
L0004:	sta     _dst_y
	sta     _dst_y+1
;
; pDst_row = raw_image;
;
L0002:	lda     #>(_raw_image)
	sta     M0001+1
	lda     #<(_raw_image)
	sta     M0001
;
; status = pjpeg_decode_mcu();
;
L0009:	jsr     _pjpeg_decode_mcu
	sta     _status
;
; if (status) {
;
	lda     _status
	beq     L000A
;
; if (status != PJPG_NO_MORE_BLOCKS) {
;
	cmp     #$01
	jeq     L0007
;
; printf("pjpeg_decode_mcu() failed with status %u\n", status);
;
	lda     #<(S004A)
	ldx     #>(S004A)
	jsr     pushax
	lda     _status
	jsr     pusha0
	ldy     #$04
	jsr     _printf
;
; return;
;
	jmp     incsp2
;
; copy_decoded_to(pDst_row);
;
L000A:	lda     M0001
	ldx     M0001+1
	jsr     _copy_decoded_to
;
; mcu_x++;
;
	inc     _mcu_x
;
; pDst_row += 8;
;
	lda     #$08
	clc
	adc     M0001
	sta     M0001
	bcc     L000C
	inc     M0001+1
;
; if (mcu_x == gMaxMCUSPerRow) {
;
L000C:	lda     _mcu_x
	cmp     #$28
	bne     L0009
;
; mcu_x = 0;
;
	lda     #$00
	sta     _mcu_x
;
; dst_y += m_MCUHeight;
;
	lda     #$08
	clc
	adc     _dst_y
	sta     _dst_y
	bcc     L000E
	inc     _dst_y+1
;
; pDst_row += QT200_HEIGHT * 2;
;
L000E:	lda     #$C0
	clc
	adc     M0001
	sta     M0001
	lda     #$03
	adc     M0001+1
	sta     M0001+1
;
; progress_bar(-1, -1, 80*22, dst_y >> 1, height);
;
	ldy     #$0A
	jsr     subysp
	lda     #$FF
	ldy     #$08
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	ldy     #$06
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	lda     #$E0
	ldy     #$04
	sta     (c_sp),y
	iny
	lda     #$06
	sta     (c_sp),y
	lda     _dst_y
	ldx     _dst_y+1
	jsr     shrax1
	ldy     #$00
	sty     sreg
	sty     sreg+1
	jsr     steax0sp
	lda     _height
	ldx     _height+1
	jsr     _progress_bar
;
; if (dst_y % (BAND_HEIGHT*2) == 0) {
;
	lda     _dst_y
	ldx     _dst_y+1
	jsr     pushax
	lda     #$28
	jsr     tosumoda0
	cpx     #$00
	jne     L0009
	cmp     #$00
	jne     L0009
;
; }
;
L0007:	jmp     incsp2

.segment	"BSS"

M0001:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ pjpeg_decode_init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_pjpeg_decode_init: near

.segment	"CODE"

;
; status = init();
;
	jsr     _init
	sta     M0001
;
; if (status)
;
	lda     M0001
	beq     L0002
;
; return status;
;
	ldx     #$00
	lda     M0001
	rts
;
; status = locateSOFMarker();
;
L0002:	jsr     _locateSOFMarker
	sta     M0001
;
; if (status)
;
	lda     M0001
	beq     L0003
;
; return status;
;
	ldx     #$00
	lda     M0001
	rts
;
; status = initFrame();
;
L0003:	jsr     _initFrame
	sta     M0001
;
; if (status)
;
	lda     M0001
	beq     L0004
;
; return status;
;
	ldx     #$00
	lda     M0001
	rts
;
; status = initScan();
;
L0004:	jsr     _initScan
	sta     M0001
;
; if (status)
;
	lda     M0001
	beq     L0005
;
; return status;
;
	ldx     #$00
	lda     M0001
	rts
;
; return 0;
;
L0005:	ldx     #$00
	txa
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ fillInBuf (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fillInBuf: near

.segment	"CODE"

;
; read(ifd, cur_cache_ptr = cache_start, CACHE_SIZE);
;
	jsr     decsp4
	lda     _ifd
	ldy     #$02
	sta     (c_sp),y
	iny
	lda     _ifd+1
	sta     (c_sp),y
	lda     _cache_start
	ldx     _cache_start+1
	sta     _prev_ram_irq_vector
	stx     _prev_ram_irq_vector+1
	ldy     #$00
	sta     (c_sp),y
	iny
	txa
	sta     (c_sp),y
	ldx     #$20
	lda     #$00
	jmp     _read

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ processRestart (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_processRestart: near

.segment	"CODE"

;
; uint8 c = 0;
;
	lda     #$00
	sta     M0002
;
; for (i = 1536; i > 0; i--) {
;
	ldx     #$06
	sta     M0001
	stx     M0001+1
L0002:	lda     M0001
	ora     M0001+1
	beq     L0003
;
; c = *(cur_cache_ptr++);
;
	ldy     #$00
	lda     (_prev_ram_irq_vector),y
	sta     M0002
	inc     _prev_ram_irq_vector
	bne     L0008
	inc     _prev_ram_irq_vector+1
;
; if (cur_cache_ptr == cache_end) {
;
L0008:	lda     _cache_end
	ldx     _cache_end+1
	cpx     _prev_ram_irq_vector+1
	bne     L0009
	cmp     _prev_ram_irq_vector
	bne     L0009
;
; fillInBuf();
;
	jsr     _fillInBuf
;
; if (c == 0xFF)
;
L0009:	lda     M0002
	cmp     #$FF
;
; break;
;
	beq     L0003
;
; for (i = 1536; i > 0; i--) {
;
	lda     M0001
	bne     L0007
	dec     M0001+1
L0007:	dec     M0001
	jmp     L0002
;
; if (i == 0)
;
L0003:	lda     M0001
	ora     M0001+1
	bne     L000B
;
; return PJPG_BAD_RESTART_MARKER;
;
	tax
	lda     #$1F
	rts
;
; for ( ; i > 0; i--) {
;
L000B:	lda     M0001
	ora     M0001+1
	beq     L000E
;
; c = *(cur_cache_ptr++);
;
	ldy     #$00
	lda     (_prev_ram_irq_vector),y
	sta     M0002
	inc     _prev_ram_irq_vector
	bne     L0013
	inc     _prev_ram_irq_vector+1
;
; if (cur_cache_ptr == cache_end) {
;
L0013:	lda     _cache_end
	ldx     _cache_end+1
	cpx     _prev_ram_irq_vector+1
	bne     L0014
	cmp     _prev_ram_irq_vector
	bne     L0014
;
; fillInBuf();
;
	jsr     _fillInBuf
;
; if (c != 0xFF)
;
L0014:	lda     M0002
	cmp     #$FF
;
; break;
;
	bne     L000E
;
; for ( ; i > 0; i--) {
;
	lda     M0001
	bne     L0012
	dec     M0001+1
L0012:	dec     M0001
	jmp     L000B
;
; if (i == 0)
;
L000E:	lda     M0001
	ora     M0001+1
	bne     L0016
;
; return PJPG_BAD_RESTART_MARKER;
;
	tax
	lda     #$1F
	rts
;
; if (c != (gNextRestartNum + M_RST0))
;
L0016:	lda     M0002
	jsr     pusha0
	lda     _gNextRestartNum
	ldx     _gNextRestartNum+1
	clc
	adc     #$D0
	bcc     L0019
	inx
L0019:	jsr     tosicmp
	beq     L0018
;
; return PJPG_BAD_RESTART_MARKER;
;
	ldx     #$00
	lda     #$1F
	rts
;
; gLastDC_h[2] = 0;
;
L0018:	lda     #$00
	sta     _gLastDC_h+2
	sta     _gLastDC_h+1
	sta     _gLastDC_h
	sta     _gLastDC_l+2
	sta     _gLastDC_l+1
	sta     _gLastDC_l
;
; gRestartsLeft = gRestartInterval;
;
	lda     _gRestartInterval+1
	sta     _gRestartsLeft+1
	lda     _gRestartInterval
	sta     _gRestartsLeft
;
; gNextRestartNum = (gNextRestartNum + 1) & 7;
;
	lda     _gNextRestartNum
	clc
	adc     #$01
	ldx     #$00
	and     #$07
	sta     _gNextRestartNum
	stx     _gNextRestartNum+1
;
; gBitsLeft = 8;
;
	lda     #$08
	sta     _zp8
;
; getBitsFF(8);
;
	jsr     _getBitsFF
;
; getBitsFF(8);
;
	lda     #$08
	jsr     _getBitsFF
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ skipVariableMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_skipVariableMarker: near

.segment	"CODE"

;
; uint16 left = getBitsNoFF(16);
;
	lda     #$10
	jsr     _getBitsNoFF
	sta     M0001
	stx     M0001+1
;
; uint16 avail = cache_end - cur_cache_ptr;
;
	lda     _cache_end
	sec
	sbc     _prev_ram_irq_vector
	sta     M0003
	lda     _cache_end+1
	sbc     _prev_ram_irq_vector+1
	sta     M0003+1
;
; if (left < 2)
;
	lda     M0001+1
	cmp     #$00
	bne     L0003
	lda     M0001
	cmp     #$02
L0003:	bcs     L0002
;
; return PJPG_BAD_VARIABLE_MARKER;
;
	ldx     #$00
	lda     #$0E
	rts
;
; left -= 2;
;
L0002:	lda     M0001
	sec
	sbc     #$02
	sta     M0001
	bcs     L0004
	dec     M0001+1
;
; if (left == 0) {
;
L0004:	lda     M0001
	ora     M0001+1
	bne     L0005
;
; return 0;
;
	tax
	rts
;
; if (left == 1) {
;
L0005:	lda     M0001+1
	bne     L0007
	lda     M0001
	cmp     #$01
	bne     L0007
;
; getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
;
; return 0;
;
	jmp     L0017
;
; safeSkip = left - 2;
;
L0007:	lda     M0001
	ldx     M0001+1
	sec
	sbc     #$02
	bcs     L0009
	dex
L0009:	sta     M0002
	stx     M0002+1
;
; if (avail > safeSkip) {
;
L000A:	lda     M0003
	sec
	sbc     M0002
	sta     tmp1
	lda     M0003+1
	sbc     M0002+1
	ora     tmp1
	bcc     L000B
	beq     L000B
;
; cur_cache_ptr += safeSkip;
;
	lda     M0002
	clc
	adc     _prev_ram_irq_vector
	sta     _prev_ram_irq_vector
	lda     M0002+1
	adc     _prev_ram_irq_vector+1
	sta     _prev_ram_irq_vector+1
;
; left -= safeSkip;
;
	lda     M0002
	eor     #$FF
	sec
	adc     M0001
	sta     M0001
	lda     M0002+1
	eor     #$FF
	adc     M0001+1
	sta     M0001+1
;
; } else {
;
	jmp     L0012
;
; safeSkip -= avail;
;
L000B:	lda     M0003
	eor     #$FF
	sec
	adc     M0002
	sta     M0002
	lda     M0003+1
	eor     #$FF
	adc     M0002+1
	sta     M0002+1
;
; left -= avail;
;
	lda     M0003
	eor     #$FF
	sec
	adc     M0001
	sta     M0001
	lda     M0003+1
	eor     #$FF
	adc     M0001+1
;
; while (safeSkip > CACHE_SIZE) {
;
	jmp     L0018
;
; lseek(ifd, CACHE_SIZE, SEEK_CUR);
;
L000D:	jsr     decsp6
	lda     _ifd
	ldy     #$04
	sta     (c_sp),y
	iny
	lda     _ifd+1
	sta     (c_sp),y
	lda     #$00
	tay
	sta     (c_sp),y
	ldy     #$02
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	lda     #$20
	ldy     #$01
	sta     (c_sp),y
	ldx     #$00
	txa
	jsr     _lseek
;
; safeSkip -= CACHE_SIZE;
;
	lda     M0002
	sec
	sta     M0002
	lda     M0002+1
	sbc     #$20
	sta     M0002+1
;
; left -= CACHE_SIZE;
;
	lda     M0001
	sec
	sta     M0001
	lda     M0001+1
	sbc     #$20
L0018:	sta     M0001+1
;
; while (safeSkip > CACHE_SIZE) {
;
	lda     M0002
	cmp     #$01
	lda     M0002+1
	sbc     #$20
	bcs     L000D
;
; fillInBuf();
;
	jsr     _fillInBuf
;
; avail = CACHE_SIZE;
;
	ldx     #$20
	lda     #$00
	sta     M0003
	stx     M0003+1
;
; goto skip_again;
;
	jmp     L000A
;
; getBitsNoFF(8);
;
L0010:	lda     #$08
	jsr     _getBitsNoFF
;
; while(left--) {
;
L0012:	lda     M0001
	ora     M0001+1
	php
	lda     M0001
	bne     L0013
	dec     M0001+1
L0013:	dec     M0001
	plp
	bne     L0010
;
; return 0;
;
L0017:	ldx     #$00
	txa
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	2,$00
M0003:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ huffCreate (unsigned char *pBits, struct HuffTableT *pHuffTable)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_huffCreate: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; uint8 i = 0;
;
	lda     #$00
	sta     M0001
;
; uint8 j = 0;
;
	sta     M0002
;
; uint16 code = 0;
;
	sta     M0003
	sta     M0003+1
;
; uint8 *l_pBits = pBits;
;
	ldy     #$03
	lda     (c_sp),y
	sta     M0004+1
	dey
	lda     (c_sp),y
	sta     M0004
;
; register uint8 *curMaxCode_l = pHuffTable->mMaxCode_l;
;
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
	ldy     #$03
	lda     (c_sp),y
	tax
	dey
	lda     (c_sp),y
	clc
	adc     #$10
	bcc     L0002
	inx
L0002:	sta     regbank+4
	stx     regbank+4+1
;
; register uint8 *curMaxCode_h = pHuffTable->mMaxCode_h;
;
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
	ldy     #$05
	lda     (c_sp),y
	tax
	dey
	lda     (c_sp),y
	clc
	adc     #$20
	bcc     L0003
	inx
L0003:	sta     regbank+2
	stx     regbank+2+1
;
; register uint8 *curMinCode_l = pHuffTable->mMinCode_l;
;
	lda     regbank+0
	ldx     regbank+1
	jsr     pushax
	ldy     #$07
	lda     (c_sp),y
	sta     regbank+0+1
	dey
	lda     (c_sp),y
	sta     regbank+0
;
; register uint8 *curValPtr = pHuffTable->mValPtr;
;
	iny
	lda     (c_sp),y
	tax
	dey
	lda     (c_sp),y
	clc
	adc     #$30
	bcc     L0004
	inx
L0004:	sta     M0005
	stx     M0005+1
;
; register uint8 *curGetMore = pHuffTable->mGetMore;
;
	iny
	lda     (c_sp),y
	tax
	dey
	lda     (c_sp),y
	clc
	adc     #$40
	bcc     L0005
	inx
L0005:	sta     M0006
	stx     M0006+1
;
; uint8 num = *l_pBits;
;
L0009:	lda     M0004+1
	sta     ptr1+1
	lda     M0004
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     M0007
;
; if (!num)
;
	lda     M0007
	bne     L000A
;
; *curGetMore = 1;
;
	lda     M0006+1
	sta     ptr1+1
	lda     M0006
	sta     ptr1
	lda     #$01
	sta     (ptr1),y
;
; else
;
	jmp     L000B
;
; uint16 max = (code + num - 1);
;
L000A:	lda     M0003
	ldx     M0003+1
	clc
	adc     M0007
	bcc     L0016
	inx
L0016:	sec
	sbc     #$01
	bcs     L000C
	dex
L000C:	sta     M0008
	stx     M0008+1
;
; *curMinCode_l = code & 0xFF;
;
	lda     M0003
	sta     (regbank+0),y
;
; *curMaxCode_l = max & 0xFF;
;
	lda     M0008
	sta     (regbank+4),y
;
; *curMaxCode_h = (max & 0xFF00) >> 8;
;
	lda     M0008+1
	sta     (regbank+2),y
;
; *curValPtr = j-1;
;
	lda     M0005+1
	sta     ptr1+1
	lda     M0005
	sta     ptr1
	lda     M0002
	sec
	sbc     #$01
	sta     (ptr1),y
;
; j = (uint8)(j + num);
;
	lda     M0002
	clc
	adc     M0007
	sta     M0002
;
; code += num;
;
	lda     M0007
	clc
	adc     M0003
	sta     M0003
	tya
	adc     M0003+1
	sta     M0003+1
;
; __asm__("asl %v", code);
;
L000B:	asl     M0003
;
; __asm__("rol %v+1", code);
;
	rol     M0003+1
;
; if (++i > 15)
;
	inc     M0001
	lda     M0001
	cmp     #$10
;
; break;
;
	bcs     L0015
;
; curMaxCode_l++;
;
	inc     regbank+4
	bne     L000F
	inc     regbank+4+1
;
; curMaxCode_h++;
;
L000F:	inc     regbank+2
	bne     L0010
	inc     regbank+2+1
;
; curMinCode_l++;
;
L0010:	inc     regbank+0
	bne     L0011
	inc     regbank+0+1
;
; curValPtr++;
;
L0011:	inc     M0005
	bne     L0012
	inc     M0005+1
;
; curGetMore++;
;
L0012:	inc     M0006
	bne     L0013
	inc     M0006+1
;
; l_pBits++;
;
L0013:	inc     M0004
	jne     L0009
	inc     M0004+1
;
; }
;
	jmp     L0009
;
; }
;
L0015:	lda     (c_sp),y
	sta     regbank+0,y
	iny
	cpy     #$06
	bne     L0015
	ldy     #$0A
	jmp     addysp

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00
M0003:
	.res	2,$00
M0004:
	.res	2,$00
M0005:
	.res	2,$00
M0006:
	.res	2,$00
M0007:
	.res	1,$00
M0008:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; struct HuffTableT *__near__ getHuffTable (unsigned char index)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getHuffTable: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; switch (index)
;
	ldx     #$00
	lda     (c_sp,x)
;
; }
;
	beq     L0004
	cmp     #$01
	beq     L0005
	cmp     #$02
	beq     L0006
	cmp     #$03
	beq     L0007
	jmp     L0009
;
; case 0: return &gHuffTab0;
;
L0004:	lda     #<(_gHuffTab0)
	ldx     #>(_gHuffTab0)
	jmp     incsp1
;
; case 1: return &gHuffTab1;
;
L0005:	lda     #<(_gHuffTab1)
	ldx     #>(_gHuffTab1)
	jmp     incsp1
;
; case 2: return &gHuffTab2;
;
L0006:	lda     #<(_gHuffTab2)
	ldx     #>(_gHuffTab2)
	jmp     incsp1
;
; case 3: return &gHuffTab3;
;
L0007:	lda     #<(_gHuffTab3)
	ldx     #>(_gHuffTab3)
	jmp     incsp1
;
; default: return 0;
;
L0009:	txa
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char *__near__ getHuffVal (unsigned char index)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getHuffVal: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; switch (index)
;
	ldx     #$00
	lda     (c_sp,x)
;
; }
;
	beq     L0004
	cmp     #$01
	beq     L0005
	cmp     #$02
	beq     L0006
	cmp     #$03
	beq     L0007
	jmp     L0009
;
; case 0: return gHuffVal0;
;
L0004:	lda     #<(_gHuffVal0)
	ldx     #>(_gHuffVal0)
	jmp     incsp1
;
; case 1: return gHuffVal1;
;
L0005:	lda     #<(_gHuffVal1)
	ldx     #>(_gHuffVal1)
	jmp     incsp1
;
; case 2: return gHuffVal2;
;
L0006:	lda     #<(_gHuffVal2)
	ldx     #>(_gHuffVal2)
	jmp     incsp1
;
; case 3: return gHuffVal3;
;
L0007:	lda     #<(_gHuffVal3)
	ldx     #>(_gHuffVal3)
	jmp     incsp1
;
; default: return 0;
;
L0009:	txa
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned int __near__ getMaxHuffCodes (unsigned char index)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getMaxHuffCodes: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; return (index < 2) ? 12 : 255;
;
	ldx     #$00
	lda     (c_sp,x)
	cmp     #$02
	bcs     L0004
	lda     #$0C
	jmp     incsp1
L0004:	lda     #$FF
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readDHTMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readDHTMarker: near

.segment	"CODE"

;
; uint16 left = getBitsNoFF(16);
;
	lda     #$10
	jsr     _getBitsNoFF
	sta     M0002
	stx     M0002+1
;
; register uint8 *ptr;
;
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; if (left < 2)
;
	lda     M0002+1
	cmp     #$00
	bne     L0003
	lda     M0002
	cmp     #$02
L0003:	bcs     L0002
;
; return PJPG_BAD_DHT_MARKER;
;
	ldx     #$00
	lda     #$04
	jmp     L0001
;
; left -= 2;
;
L0002:	lda     M0002
	sec
	sbc     #$02
	sta     M0002
	jcs     L0007
	dec     M0002+1
;
; while (left)
;
	jmp     L0007
;
; index = (uint8)getBitsNoFF(8);
;
L0005:	lda     #$08
	jsr     _getBitsNoFF
	sta     M0005
;
; if ( ((index & 0xF) > 1) || ((index & 0xF0) > 0x10) )
;
	and     #$0F
	cmp     #$02
	lda     #$00
	sbc     #$00
	bvs     L0009
	eor     #$80
L0009:	bmi     L001C
	lda     M0005
	and     #$F0
	cmp     #$11
	lda     #$00
	sbc     #$00
	bvs     L000B
	eor     #$80
L000B:	bpl     L001D
;
; return PJPG_BAD_DHT_INDEX;
;
L001C:	ldx     #$00
	lda     #$03
	jmp     L0001
;
; tableIndex = ((index >> 3) & 2) + (index & 1);
;
L001D:	lda     M0005
	lsr     a
	lsr     a
	lsr     a
	and     #$02
	sta     ptr1
	lda     M0005
	and     #$01
	clc
	adc     ptr1
	sta     M0004
;
; pHuffTable = getHuffTable(tableIndex);
;
	jsr     _getHuffTable
	sta     M0007
	stx     M0007+1
;
; pHuffVal = getHuffVal(tableIndex);
;
	lda     M0004
	jsr     _getHuffVal
	sta     M0006
	stx     M0006+1
;
; count = 0;
;
	lda     #$00
	sta     M0008
	sta     M0008+1
;
; ptr = bits;
;
	lda     #>(M0001)
	sta     regbank+4+1
	lda     #<(M0001)
	sta     regbank+4
;
; for (i = 0; i <= 15; i++)
;
	lda     #$00
	sta     M0003
L001E:	lda     M0003
	cmp     #$10
	bcs     L000E
;
; uint8 n = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M000A
;
; *(ptr++) = n;
;
	ldy     #$00
	sta     (regbank+4),y
	inc     regbank+4
	bne     L0011
	inc     regbank+4+1
;
; count = (uint16)(count + n);
;
L0011:	lda     M0008
	ldx     M0008+1
	clc
	adc     M000A
	bcc     L001A
	inx
L001A:	sta     M0008
	stx     M0008+1
;
; for (i = 0; i <= 15; i++)
;
	inc     M0003
	jmp     L001E
;
; if (count > getMaxHuffCodes(tableIndex))
;
L000E:	lda     M0008
	ldx     M0008+1
	jsr     pushax
	lda     M0004
	jsr     _getMaxHuffCodes
	jsr     tosicmp
	bcc     L0012
	beq     L0012
;
; return PJPG_BAD_DHT_COUNTS;
;
	ldx     #$00
	lda     #$02
	jmp     L0001
;
; ptr = pHuffVal;
;
L0012:	lda     M0006+1
	sta     regbank+4+1
	lda     M0006
	sta     regbank+4
;
; for (i = 0; i < count; i++)
;
	lda     #$00
	sta     M0003
	tax
L001F:	lda     M0003
	cmp     M0008
	txa
	sbc     M0008+1
	bcs     L0014
;
; *(ptr++) = (uint8)getBitsNoFF(8);
;
	lda     regbank+4
	ldx     regbank+4+1
	jsr     pushax
	lda     #$08
	inc     regbank+4
	bne     L0017
	inc     regbank+4+1
L0017:	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; for (i = 0; i < count; i++)
;
	ldx     #$00
	inc     M0003
	jmp     L001F
;
; totalRead = count + (1+16);
;
L0014:	lda     M0008
	ldx     M0008+1
	clc
	adc     #$11
	bcc     L0018
	inx
L0018:	sta     M0009
	stx     M0009+1
;
; if (left < totalRead)
;
	lda     M0002
	cmp     M0009
	lda     M0002+1
	sbc     M0009+1
	bcs     L0019
;
; return PJPG_BAD_DHT_MARKER;
;
	ldx     #$00
	lda     #$04
	jmp     L0001
;
; left = (uint16)(left - totalRead);
;
L0019:	lda     M0002
	sec
	sbc     M0009
	sta     M0002
	lda     M0002+1
	sbc     M0009+1
	sta     M0002+1
;
; huffCreate(bits, pHuffTable);
;
	lda     #<(M0001)
	ldx     #>(M0001)
	jsr     pushax
	lda     M0007
	ldx     M0007+1
	jsr     _huffCreate
;
; while (left)
;
L0007:	lda     M0002
	ora     M0002+1
	jne     L0005
;
; return 0;
;
	tax
;
; }
;
L0001:	pha
	lda     (c_sp,x)
	sta     regbank+4
	ldy     #$01
	lda     (c_sp),y
	sta     regbank+5
	pla
	jmp     incsp2

.segment	"BSS"

M0001:
	.res	16,$00
M0002:
	.res	2,$00
M0003:
	.res	1,$00
M0004:
	.res	1,$00
M0005:
	.res	1,$00
M0006:
	.res	2,$00
M0007:
	.res	2,$00
M0008:
	.res	2,$00
M0009:
	.res	2,$00
M000A:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readDQTMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readDQTMarker: near

.segment	"CODE"

;
; uint16 left = getBitsNoFF(16);
;
	lda     #$10
	jsr     _getBitsNoFF
	sta     M0001
	stx     M0001+1
;
; if (left < 2)
;
	cpx     #$00
	bne     L0003
	cmp     #$02
L0003:	bcs     L0002
;
; return PJPG_BAD_DQT_MARKER;
;
	ldx     #$00
	lda     #$05
	rts
;
; left -= 2;
;
L0002:	lda     M0001
	sec
	sbc     #$02
	sta     M0001
	jcs     L0007
	dec     M0001+1
;
; while (left)
;
	jmp     L0007
;
; uint8 n = (uint8)getBitsNoFF(8);
;
L0005:	lda     #$08
	jsr     _getBitsNoFF
	sta     M0003
;
; uint8 prec = n >> 4;
;
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     M0004
;
; n &= 0x0F;
;
	lda     M0003
	and     #$0F
	sta     M0003
;
; if (n > 1)
;
	cmp     #$02
	bcc     L0008
;
; return PJPG_BAD_DQT_TABLE;
;
	ldx     #$00
	lda     #$06
	rts
;
; if (n) {
;
L0008:	lda     M0003
	beq     L0022
;
; gValidQuantTables |= 2;
;
	lda     _gValidQuantTables
	ora     #$02
	sta     _gValidQuantTables
;
; for (i = 0; i < 64; i++)
;
	lda     #$00
	sta     M0002
L0021:	lda     M0002
	cmp     #$40
	bcs     L000B
;
; if (prec) {
;
	lda     M0004
	beq     L000E
;
; gQuant1_h[i] = getBitsNoFF(8);
;
	lda     #<(_gQuant1_h)
	ldx     #>(_gQuant1_h)
	clc
	adc     M0002
	bcc     L000F
	inx
L000F:	jsr     pushax
	lda     #$08
	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; } else {
;
	jmp     L002C
;
; gQuant1_h[i] = 0;
;
L000E:	ldy     M0002
	sta     _gQuant1_h,y
;
; gQuant1_l[i] = getBitsNoFF(8);
;
L002C:	lda     #<(_gQuant1_l)
	ldx     #>(_gQuant1_l)
	clc
	adc     M0002
	bcc     L0013
	inx
L0013:	jsr     pushax
	lda     #$08
	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; for (i = 0; i < 64; i++)
;
	inc     M0002
	jmp     L0021
;
; createWinogradQuant1();
;
L000B:	jsr     _createWinogradQuant1
;
; } else {
;
	jmp     L0014
;
; gValidQuantTables |= 1;
;
L0022:	lda     _gValidQuantTables
	ora     #$01
	sta     _gValidQuantTables
;
; for (i = 0; i < 64; i++)
;
	lda     #$00
	sta     M0002
L0023:	lda     M0002
	cmp     #$40
	bcs     L0016
;
; uint16 temp = getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0006
	stx     M0006+1
;
; if (prec)
;
	lda     M0004
	beq     L0019
;
; temp = (temp << 8) + getBitsNoFF(8);
;
	ldx     M0006
	lda     #$00
	jsr     pushax
	lda     #$08
	jsr     _getBitsNoFF
	jsr     tosaddax
	sta     M0006
	stx     M0006+1
;
; gQuant0_h[i] = (int8)(temp>>8);
;
L0019:	lda     #<(_gQuant0_h)
	ldx     #>(_gQuant0_h)
	clc
	adc     M0002
	bcc     L001A
	inx
L001A:	sta     ptr1
	stx     ptr1+1
	lda     M0006+1
	cmp     #$80
	ldy     #$00
	sta     (ptr1),y
;
; gQuant0_l[i] = (int8)(temp);
;
	ldy     M0002
	lda     M0006
	sta     _gQuant0_l,y
;
; for (i = 0; i < 64; i++)
;
	inc     M0002
	jmp     L0023
;
; createWinogradQuant0();
;
L0016:	jsr     _createWinogradQuant0
;
; totalRead = 64 + 1;
;
L0014:	ldx     #$00
	lda     #$41
	sta     M0005
	stx     M0005+1
;
; if (prec)
;
	lda     M0004
	beq     L001D
;
; totalRead += 64;
;
	lda     #$40
	clc
	adc     M0005
	sta     M0005
	bcc     L001D
	inc     M0005+1
;
; if (left < totalRead)
;
L001D:	lda     M0001
	cmp     M0005
	lda     M0001+1
	sbc     M0005+1
	bcs     L001F
;
; return PJPG_BAD_DQT_LENGTH;
;
	lda     #$17
	rts
;
; left = (uint16)(left - totalRead);
;
L001F:	lda     M0001
	sec
	sbc     M0005
	sta     M0001
	lda     M0001+1
	sbc     M0005+1
	sta     M0001+1
;
; while (left)
;
L0007:	lda     M0001
	ora     M0001+1
	jne     L0005
;
; return 0;
;
	tax
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	1,$00
M0003:
	.res	1,$00
M0004:
	.res	1,$00
M0005:
	.res	2,$00
M0006:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readSOFMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readSOFMarker: near

.segment	"CODE"

;
; uint16 left = getBitsNoFF(16);
;
	lda     #$10
	jsr     _getBitsNoFF
	sta     M0002
	stx     M0002+1
;
; register uint8 *ptr_ident, *ptr_quant, *ptr_hsamp;
;
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
	lda     regbank+0
	ldx     regbank+1
	jsr     pushax
;
; if (getBitsNoFF(8) != 8)
;
	lda     #$08
	jsr     _getBitsNoFF
	cpx     #$00
	bne     L001C
	cmp     #$08
	beq     L0002
;
; return PJPG_BAD_PRECISION;
;
L001C:	ldx     #$00
	lda     #$07
	jmp     L0001
;
; gImageYSize = getBitsNoFF(16);
;
L0002:	lda     #$10
	jsr     _getBitsNoFF
	sta     M0004
	stx     M0004+1
;
; if (gImageYSize != QT200_HEIGHT)
;
	cpx     #$01
	bne     L001D
	cmp     #$E0
	beq     L0004
;
; return PJPG_BAD_HEIGHT;
;
L001D:	ldx     #$00
	lda     #$0A
	jmp     L0001
;
; gImageXSize = getBitsNoFF(16);
;
L0004:	lda     #$10
	jsr     _getBitsNoFF
	sta     M0003
	stx     M0003+1
;
; if (gImageXSize  != QT200_WIDTH)
;
	cpx     #$02
	bne     L001E
	cmp     #$80
	beq     L0006
;
; return PJPG_BAD_WIDTH;
;
L001E:	ldx     #$00
	lda     #$0B
	jmp     L0001
;
; gCompsInFrame = (uint8)getBitsNoFF(8);
;
L0006:	lda     #$08
	jsr     _getBitsNoFF
	sta     _gCompsInFrame
;
; if (gCompsInFrame > 3)
;
	cmp     #$04
	bcc     L0008
;
; return PJPG_TOO_MANY_COMPONENTS;
;
	ldx     #$00
	lda     #$0C
	jmp     L0001
;
; if (left != (gCompsInFrame + gCompsInFrame + gCompsInFrame + 8))
;
L0008:	lda     M0002
	ldx     M0002+1
	jsr     pushax
	ldx     #$00
	lda     _gCompsInFrame
	clc
	adc     _gCompsInFrame
	bcc     L0017
	inx
	clc
L0017:	adc     _gCompsInFrame
	bcc     L0018
	inx
	clc
L0018:	adc     #$08
	bcc     L000A
	inx
L000A:	jsr     tosicmp
	beq     L0009
;
; return PJPG_BAD_SOF_LENGTH;
;
	ldx     #$00
	lda     #$0D
	jmp     L0001
;
; ptr_ident = gCompIdent;
;
L0009:	lda     #>(_gCompIdent)
	sta     regbank+4+1
	lda     #<(_gCompIdent)
	sta     regbank+4
;
; ptr_quant = gCompQuant;
;
	lda     #>(_gCompQuant)
	sta     regbank+2+1
	lda     #<(_gCompQuant)
	sta     regbank+2
;
; ptr_hsamp = gCompHSamp;
;
	lda     #>(_gCompHSamp)
	sta     regbank+0+1
	lda     #<(_gCompHSamp)
	sta     regbank+0
;
; for (i = 0; i < gCompsInFrame; i++)
;
	lda     #$00
	sta     M0001
	tax
L0019:	lda     M0001
	cmp     _gCompsInFrame
	bcs     L001B
;
; *(ptr_ident++) = (uint8)getBitsNoFF(8);
;
	lda     regbank+4
	ldx     regbank+4+1
	jsr     pushax
	lda     #$08
	inc     regbank+4
	bne     L000F
	inc     regbank+4+1
L000F:	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; *(ptr_hsamp++) = (uint8)getBitsNoFF(4);
;
	lda     regbank+0
	ldx     regbank+0+1
	jsr     pushax
	lda     #$04
	inc     regbank+0
	bne     L0010
	inc     regbank+0+1
L0010:	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; gCompVSamp[i] = (uint8)getBitsNoFF(4);
;
	lda     #<(_gCompVSamp)
	ldx     #>(_gCompVSamp)
	clc
	adc     M0001
	bcc     L0011
	inx
L0011:	jsr     pushax
	lda     #$04
	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; *(ptr_quant) = (uint8)getBitsNoFF(8);
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	lda     #$08
	jsr     _getBitsNoFF
	ldy     #$00
	jsr     staspidx
;
; if (*ptr_quant > 1)
;
	ldy     #$00
	lda     (regbank+2),y
	cmp     #$02
	ldx     #$00
	bcc     L0012
;
; return PJPG_UNSUPPORTED_QUANT_TABLE;
;
	lda     #$26
	jmp     L0001
;
; ptr_quant++;
;
L0012:	inc     regbank+2
	bne     L001A
	inc     regbank+2+1
;
; for (i = 0; i < gCompsInFrame; i++)
;
L001A:	inc     M0001
	jmp     L0019
;
; return 0;
;
L001B:	txa
;
; }
;
L0001:	pha
	ldy     #$00
L0014:	lda     (c_sp),y
	sta     regbank+0,y
	iny
	cpy     #$06
	bne     L0014
	pla
	jmp     incsp6

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	2,$00
M0003:
	.res	2,$00
M0004:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readDRIMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readDRIMarker: near

.segment	"CODE"

;
; if (getBitsNoFF(16) != 4)
;
	lda     #$10
	jsr     _getBitsNoFF
	cpx     #$00
	bne     L0004
	cmp     #$04
	beq     L0002
;
; return PJPG_BAD_DRI_LENGTH;
;
L0004:	ldx     #$00
	lda     #$0F
	rts
;
; gRestartInterval = getBitsNoFF(16);
;
L0002:	lda     #$10
	jsr     _getBitsNoFF
	sta     _gRestartInterval
	stx     _gRestartInterval+1
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ readSOSMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_readSOSMarker: near

.segment	"CODE"

;
; uint16 left = getBitsNoFF(16);
;
	lda     #$10
	jsr     _getBitsNoFF
	sta     M0002
	stx     M0002+1
;
; gCompsInScan = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     _gCompsInScan
;
; left -= 3;
;
	lda     M0002
	sec
	sbc     #$03
	sta     M0002
	bcs     L0002
	dec     M0002+1
;
; if ( (left != (gCompsInScan + gCompsInScan + 3)) || (gCompsInScan < 1) || (gCompsInScan > PJPG_MAXCOMPSINSCAN) )
;
L0002:	lda     M0002
	ldx     M0002+1
	jsr     pushax
	ldx     #$00
	lda     _gCompsInScan
	clc
	adc     _gCompsInScan
	bcc     L001C
	inx
	clc
L001C:	adc     #$03
	bcc     L0004
	inx
L0004:	jsr     tosicmp
	bne     L001D
	lda     _gCompsInScan
	beq     L001D
	cmp     #$04
	bcs     L001D
	lda     #$00
	jmp     L001F
;
; return PJPG_BAD_SOS_LENGTH;
;
L001D:	ldx     #$00
	lda     #$10
	rts
;
; for (i = 0; i < gCompsInScan; i++)
;
L001F:	sta     M0001
L0020:	lda     M0001
	cmp     _gCompsInScan
	jcs     L0023
;
; uint8 cc = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0007
;
; uint8 c = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0008
;
; left -= 2;
;
	lda     M0002
	sec
	sbc     #$02
	sta     M0002
	bcs     L000B
	dec     M0002+1
;
; for (ci = 0; ci < gCompsInFrame; ci++)
;
L000B:	lda     #$00
	sta     M0009
L0021:	lda     M0009
	cmp     _gCompsInFrame
	bcs     L0022
;
; if (cc == gCompIdent[ci])
;
	lda     M0007
	ldy     M0009
	cmp     _gCompIdent,y
;
; break;
;
	beq     L0022
;
; for (ci = 0; ci < gCompsInFrame; ci++)
;
	inc     M0009
	jmp     L0021
;
; if (ci >= gCompsInFrame)
;
L0022:	lda     M0009
	cmp     _gCompsInFrame
	bcc     L0012
;
; return PJPG_BAD_SOS_COMP_ID;
;
	ldx     #$00
	lda     #$11
	rts
;
; gCompList[i]    = ci;
;
L0012:	ldy     M0001
	lda     M0009
	sta     _gCompList,y
;
; gCompDCTab[ci] = (c >> 4) & 15;
;
	lda     #<(_gCompDCTab)
	ldx     #>(_gCompDCTab)
	clc
	adc     M0009
	bcc     L0014
	inx
L0014:	sta     ptr1
	stx     ptr1+1
	lda     M0008
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	and     #$0F
	ldy     #$00
	sta     (ptr1),y
;
; gCompACTab[ci] = (c & 15);
;
	lda     #<(_gCompACTab)
	ldx     #>(_gCompACTab)
	clc
	adc     M0009
	bcc     L0015
	inx
L0015:	sta     ptr1
	stx     ptr1+1
	lda     M0008
	and     #$0F
	sta     (ptr1),y
;
; for (i = 0; i < gCompsInScan; i++)
;
	inc     M0001
	jmp     L0020
;
; spectral_start  = (uint8)getBitsNoFF(8);
;
L0023:	lda     #$08
	jsr     _getBitsNoFF
	sta     M0003
;
; spectral_end    = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0004
;
; successive_high = (uint8)getBitsNoFF(4);
;
	lda     #$04
	jsr     _getBitsNoFF
	sta     M0005
;
; successive_low  = (uint8)getBitsNoFF(4);
;
	lda     #$04
	jsr     _getBitsNoFF
	sta     M0006
;
; left -= 3;
;
	lda     M0002
	sec
	sbc     #$03
	sta     M0002
	bcs     L0019
	dec     M0002+1
;
; while (left)
;
	jmp     L0019
;
; getBitsNoFF(8);
;
L0017:	lda     #$08
	jsr     _getBitsNoFF
;
; left--;
;
	lda     M0002
	bne     L001A
	dec     M0002+1
L001A:	dec     M0002
;
; while (left)
;
L0019:	lda     M0002
	ora     M0002+1
	bne     L0017
;
; return 0;
;
	tax
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	2,$00
M0003:
	.res	1,$00
M0004:
	.res	1,$00
M0005:
	.res	1,$00
M0006:
	.res	1,$00
M0007:
	.res	1,$00
M0008:
	.res	1,$00
M0009:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ nextMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nextMarker: near

.segment	"CODE"

;
; c = (uint8)getBitsNoFF(8);
;
L000B:	lda     #$08
	jsr     _getBitsNoFF
	sta     M0001
;
; } while (c != 0xFF);
;
	cmp     #$FF
	bne     L000B
;
; c = (uint8)getBitsNoFF(8);
;
L000C:	lda     #$08
	jsr     _getBitsNoFF
	sta     M0001
;
; } while (c == 0xFF);
;
	cmp     #$FF
	beq     L000C
;
; } while (c == 0);
;
	lda     M0001
	beq     L000B
;
; return c;
;
	ldx     #$00
	lda     M0001
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ processMarkers (unsigned char *pMarker)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_processMarkers: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; uint8 c = nextMarker();
;
L0005:	jsr     _nextMarker
	sta     M0001
;
; switch (c)
;
	ldx     #$00
	lda     M0001
;
; }
;
	cmp     #$01
	jeq     L0028
	cmp     #$C0
	beq     L0008
	cmp     #$C1
	beq     L0008
	cmp     #$C2
	beq     L0008
	cmp     #$C3
	beq     L0008
	cmp     #$C4
	beq     L0018
	cmp     #$C5
	beq     L0008
	cmp     #$C6
	beq     L0008
	cmp     #$C7
	beq     L0008
	cmp     #$C8
	jeq     L0028
	cmp     #$C9
	beq     L0008
	cmp     #$CA
	beq     L0008
	cmp     #$CB
	beq     L0008
	cmp     #$CC
	beq     L0027
	cmp     #$CD
	beq     L0008
	cmp     #$CE
	beq     L0008
	cmp     #$CF
	beq     L0008
	cmp     #$D0
	beq     L0028
	cmp     #$D1
	beq     L0028
	cmp     #$D2
	beq     L0028
	cmp     #$D3
	beq     L0028
	cmp     #$D4
	beq     L0028
	cmp     #$D5
	beq     L0028
	cmp     #$D6
	beq     L0028
	cmp     #$D7
	beq     L0028
	cmp     #$D8
	beq     L0008
	cmp     #$D9
	beq     L0008
	cmp     #$DA
	beq     L0008
	cmp     #$DB
	beq     L001A
	cmp     #$DD
	beq     L001B
	jmp     L0026
;
; *pMarker = c;
;
L0008:	ldy     #$01
	lda     (c_sp),y
	sta     ptr1+1
	dey
	lda     (c_sp),y
	sta     ptr1
	lda     M0001
	sta     (ptr1),y
;
; return 0;
;
	txa
	jmp     incsp2
;
; readDHTMarker();
;
L0018:	jsr     _readDHTMarker
;
; break;
;
	jmp     L0005
;
; return PJPG_NO_ARITHMITIC_SUPPORT;
;
L0027:	lda     #$13
	jmp     incsp2
;
; readDQTMarker();
;
L001A:	jsr     _readDQTMarker
;
; break;
;
	jmp     L0005
;
; readDRIMarker();
;
L001B:	jsr     _readDRIMarker
;
; break;
;
	jmp     L0005
;
; return PJPG_UNEXPECTED_MARKER;
;
L0028:	lda     #$14
	jmp     incsp2
;
; skipVariableMarker();
;
L0026:	jsr     _skipVariableMarker
;
; break;
;
	jmp     L0005

.segment	"BSS"

M0001:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ locateSOIMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_locateSOIMarker: near

.segment	"CODE"

;
; uint8 lastchar = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0002
;
; uint8 thischar = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0003
;
; if ((lastchar == 0xFF) && (thischar == M_SOI))
;
	lda     M0002
	cmp     #$FF
	bne     L0002
	lda     M0003
	cmp     #$D8
	bne     L0002
;
; return 0;
;
	ldx     #$00
	jmp     L0011
;
; bytesleft = 4096; //512;
;
L0002:	ldx     #$10
	lda     #$00
	sta     M0001
	stx     M0001+1
;
; if (--bytesleft == 0)
;
L0009:	ldx     M0001
	bne     L000B
	dec     M0001+1
L000B:	dex
	stx     M0001
	txa
	ldx     M0001+1
	cpx     #$00
	bne     L000A
	cmp     #$00
	bne     L000A
;
; return PJPG_NOT_JPEG;
;
	lda     #$15
	rts
;
; lastchar = thischar;
;
L000A:	lda     M0003
	sta     M0002
;
; thischar = (uint8)getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
	sta     M0003
;
; if (lastchar == 0xFF)
;
	lda     M0002
	cmp     #$FF
	bne     L0009
;
; if (thischar == M_SOI)
;
	lda     M0003
	cmp     #$D8
;
; break;
;
	beq     L0014
;
; if (thischar == M_EOI) //getBitsNoFF will keep returning M_EOI if we read past the end
;
	cmp     #$D9
	bne     L0009
;
; return PJPG_NOT_JPEG;
;
	ldx     #$00
	lda     #$15
	rts
;
; thischar = (uint8)((gBitBuf >> 8) & 0xFF);
;
L0014:	lda     _zp2i+1
	sta     M0003
;
; if (thischar != 0xFF)
;
	ldx     #$00
	lda     M0003
	cmp     #$FF
	beq     L0011
;
; return PJPG_NOT_JPEG;
;
	lda     #$15
	rts
;
; return 0;
;
L0011:	txa
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	1,$00
M0003:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ locateSOFMarker (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_locateSOFMarker: near

.segment	"CODE"

;
; uint8 status = locateSOIMarker();
;
	jsr     _locateSOIMarker
	sta     M0002
;
; if (status)
;
	lda     M0002
	beq     L0002
;
; return status;
;
	ldx     #$00
	lda     M0002
	rts
;
; status = processMarkers(&c);
;
L0002:	lda     #<(M0001)
	ldx     #>(M0001)
	jsr     _processMarkers
	sta     M0002
;
; if (status)
;
	lda     M0002
	beq     L0003
;
; return status;
;
	ldx     #$00
	lda     M0002
	rts
;
; switch (c)
;
L0003:	ldx     #$00
	lda     M0001
;
; }
;
	cmp     #$C0
	beq     L0007
	cmp     #$C1
	beq     L000E
	cmp     #$C2
	beq     L000C
	cmp     #$C9
	beq     L000D
	jmp     L000E
;
; return PJPG_UNSUPPORTED_MODE;
;
L000C:	lda     #$27
	rts
;
; status = readSOFMarker();
;
L0007:	jsr     _readSOFMarker
	sta     M0002
;
; if (status)
;
	lda     M0002
	beq     L0005
;
; return status;
;
	ldx     #$00
	lda     M0002
	rts
;
; return PJPG_NO_ARITHMITIC_SUPPORT;
;
L000D:	lda     #$13
	rts
;
; return PJPG_UNSUPPORTED_MARKER;
;
L000E:	lda     #$16
	rts
;
; return 0;
;
L0005:	ldx     #$00
	txa
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ locateSOSMarker (unsigned char *pFoundEOI)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_locateSOSMarker: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; *pFoundEOI = 0;
;
	ldy     #$01
	lda     (c_sp),y
	sta     ptr1+1
	dey
	lda     (c_sp),y
	sta     ptr1
	tya
	sta     (ptr1),y
;
; status = processMarkers(&c);
;
	lda     #<(M0001)
	ldx     #>(M0001)
	jsr     _processMarkers
	sta     M0002
;
; if (status)
;
	lda     M0002
	beq     L0002
;
; return status;
;
	ldx     #$00
	lda     M0002
	jmp     incsp2
;
; if (c == M_EOI)
;
L0002:	lda     M0001
	cmp     #$D9
	bne     L0005
;
; *pFoundEOI = 1;
;
	ldy     #$01
	lda     (c_sp),y
	sta     ptr1+1
	dey
	lda     (c_sp),y
	sta     ptr1
	lda     #$01
	sta     (ptr1),y
;
; return 0;
;
	ldx     #$00
	txa
	jmp     incsp2
;
; if (c != M_SOS)
;
L0005:	lda     M0001
	cmp     #$DA
	beq     L0004
;
; return PJPG_UNEXPECTED_MARKER;
;
	ldx     #$00
	lda     #$14
	jmp     incsp2
;
; return readSOSMarker();
;
L0004:	jsr     _readSOSMarker
;
; }
;
	jmp     incsp2

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init: near

.segment	"CODE"

;
; gBitBuf = 0;
;
	lda     #$00
	sta     _zp2i
	sta     _zp2i+1
	sta     _gTemFlag
	sta     _gValidQuantTables
	sta     _gCompsInScan
	sta     _gRestartInterval
	sta     _gRestartInterval+1
	sta     _gCompsInFrame
;
; gBitsLeft = 8;
;
	lda     #$08
	sta     _zp8
;
; getBitsNoFF(8);
;
	jsr     _getBitsNoFF
;
; getBitsNoFF(8);
;
	lda     #$08
	jsr     _getBitsNoFF
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ fixInBuffer (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fixInBuffer: near

.segment	"CODE"

;
; if (gBitsLeft > 0)
;
	lda     _zp8
	beq     L0002
;
; *(cur_cache_ptr--) = (uint8)gBitBuf;
;
	lda     _zp2i
	ldy     #$00
	sta     (_prev_ram_irq_vector),y
	lda     _prev_ram_irq_vector
	bne     L0003
	dec     _prev_ram_irq_vector+1
L0003:	dec     _prev_ram_irq_vector
;
; *(cur_cache_ptr--) = (uint8)(gBitBuf >> 8);
;
L0002:	lda     _zp2i+1
	ldy     #$00
	sta     (_prev_ram_irq_vector),y
	lda     _prev_ram_irq_vector
	bne     L0004
	dec     _prev_ram_irq_vector+1
L0004:	dec     _prev_ram_irq_vector
;
; gBitsLeft = 8;
;
	lda     #$08
	sta     _zp8
;
; getBitsFF(16);
;
	lda     #$10
	jmp     _getBitsFF

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ initScan (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_initScan: near

.segment	"CODE"

;
; uint8 status = locateSOSMarker(&foundEOI);
;
	lda     #<(M0001)
	ldx     #>(M0001)
	jsr     _locateSOSMarker
	sta     M0002
;
; if (status)
;
	lda     M0002
	beq     L0002
;
; return status;
;
	ldx     #$00
	lda     M0002
	rts
;
; if (foundEOI)
;
L0002:	lda     M0001
	beq     L0005
;
; return PJPG_UNEXPECTED_MARKER;
;
	ldx     #$00
	lda     #$14
	rts
;
; gLastDC_h[2] = 0;
;
L0005:	sta     _gLastDC_h+2
	sta     _gLastDC_h+1
	sta     _gLastDC_h
	sta     _gLastDC_l+2
	sta     _gLastDC_l+1
	sta     _gLastDC_l
;
; if (gRestartInterval)
;
	lda     _gRestartInterval
	ora     _gRestartInterval+1
	beq     L0004
;
; gRestartsLeft = gRestartInterval;
;
	lda     _gRestartInterval+1
	sta     _gRestartsLeft+1
	lda     _gRestartInterval
	sta     _gRestartsLeft
;
; gNextRestartNum = 0;
;
	lda     #$00
	sta     _gNextRestartNum
	sta     _gNextRestartNum+1
;
; fixInBuffer();
;
L0004:	jsr     _fixInBuffer
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ initFrame (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_initFrame: near

.segment	"CODE"

;
; gMaxBlocksPerMCU = 4;
;
	lda     #$04
	sta     _gMaxBlocksPerMCU
;
; gMCUOrg[0] = 0;
;
	lda     #$00
	sta     _gMCUOrg
;
; gMCUOrg[1] = 0;
;
	sta     _gMCUOrg+1
;
; gMCUOrg[2] = 1;
;
	lda     #$01
	sta     _gMCUOrg+2
;
; gMCUOrg[3] = 2;
;
	lda     #$02
	sta     _gMCUOrg+3
;
; gNumMCUSRemainingX = gMaxMCUSPerRow;
;
	lda     #$28
	sta     _gNumMCUSRemainingX
;
; gNumMCUSRemainingY = gMaxMCUSPerCol;
;
	lda     #$3C
	sta     _gNumMCUSRemainingY
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	rts

.endproc

