;
; File generated by cc65 v 2.19 - Git 51b946bf2
;
        .importzp       c_sp
        .importzp       tmp4
        .importzp       _prev_ram_irq_vector, _zp4ip

        .import         decsp4
        .import         _read
        .import         _cache_start
        .import         _cache_end
        .import         _ifd
        .import         floppy_motor_on
        .export         _huff_num
        .export         _getbithuff6, _getbithuff8
        .export         _cache
        .export         _init_floppy_starter
        .export         _buf_0, _buf_1, _buf_2, _huff_split
        .importzp       _zp8i, _zp10, _zp11, _zp12
cur_cache_ptr = _prev_ram_irq_vector

.segment        "BSS"
.align 256
_cache:        .res        CACHE_SIZE,$00
_buf_0:        .res        $400
_buf_1:        .res        $400
_buf_2:        .res        $400
_huff_split:   .res        19*256*2
CACHE_END = _cache + CACHE_SIZE
.assert <CACHE_END = 0, error

_bitbuf     = _zp8i
_vbits      = _zp10
nbits       = _zp11
final_shift = _zp12
motor_on:.res 1

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ getbithuff (unsigned char n)
; ---------------------------------------------------------------

.segment        "CODE"

_init_floppy_starter:
        ldy     #0                      ; Init bitbuf (consider cache full at very start)
        lda     (cur_cache_ptr),y
        sta     _bitbuf+1
        iny
        lda     (cur_cache_ptr),y
        sta     _bitbuf
        lda     #16
        sta     _vbits

        lda     cur_cache_ptr           ; Init local cache pointer
        clc
        adc     #2                      ; Consider no crossing at very start
        sta     cache_read
        lda     cur_cache_ptr+1
        sta     cache_read+1

        lda     floppy_motor_on         ; Patch motor_on if we use a floppy
        beq     :+
        sta     start_floppy_motor+1
        lda     #$C0                    ; Firmware access space
        sta     start_floppy_motor+2
:       rts

refill:
        ldx     _bitbuf
        stx     _bitbuf+1
        ; _bitbuf low byte will be set below

cache_read = *+1
        lda     $FFFF
        sta     _bitbuf

        ldy     _vbits
        ldx     plus8,y
        stx     _vbits       ; vbits in X for return

        inc     cache_read
        bne     left_right_shift

inc_cache_high:
        inc     cache_read+1
        lda     cache_read+1

        ; Check for cache almost-end and restart floppy
        ; Consider we have time to handle 256b while the
        ; drive restarts
        cmp     #(>CACHE_END)-1
        bcc     left_right_shift
start_floppy_motor:
        sta     motor_on                 ; Patched if on floppy

        cmp     #(>CACHE_END)
        bne     left_right_shift


        ; Push read fd
        jsr     decsp4
        ldy     #$03

        lda     #$00                    ; ifd is never going to be > 255
        sta     (c_sp),y
        dey
        lda     _ifd
        sta     (c_sp),y
        dey

        ; Push buffer
        lda     _cache_start+1
        sta     cache_read+1
        sta     (c_sp),y
        dey

        lda     _cache_start
        sta     cache_read
        sta     (c_sp),y

        ; Push count (CACHE_SIZE)
        lda     #<CACHE_SIZE
        ldx     #>CACHE_SIZE
        jsr     _read
        clc
        ldx     _vbits
        jmp     left_right_shift

_getbithuff6:
        ldy     #6
        jmp     _getbithuff
_getbithuff8:
        ldy     #8
_getbithuff:
        sty     nbits
        ldx     min8,y
        stx     final_shift

        ldx     _vbits
        cpx     #12
        bcs     left_right_shift
        cpx     #9
        bcc     refill
direct_right_shift:
        txa
        sec
        sbc     nbits
        tay                     ; Can't be zero
        lda     _bitbuf
        ldx     _bitbuf+1
        stx     tmp4

:       lsr     tmp4
        ror     a
        dey
        bne     :-
        ldy     final_shift
        and     mask,y
        jmp     do_huff_h

left_right_shift:
        lda     _bitbuf+1     ; Load the uint16 bitbuf
        ldy     min16,x       ; shift = 16-vbits
        beq     lshift_done_h
        ldx     _bitbuf+0     ; (high byte in A because that's the one we keep)
        stx     tmp4

:       asl     tmp4
        rol     a
        dey
        bne     :-              ; Now we have 0x000AABB0

lshift_done_h:
        ldy     final_shift     ; and do the final shift
        beq     do_huff_h

:       lsr     a
        dey
        bne     :-              ; Final shift done!

do_huff_h:
        tay                     ; Backup result/Use as huff index
        lda     _vbits          ; Prepare for decrement
        sec

        ldx     _huff_num
        beq     no_huff
        inx                     ; high page
        stx     ha+2

ha:
        sbc     _huff_split+256,y
        sta     _vbits
_huff_num = *+2
        lda     _huff_split,y
        rts
no_huff:
        sbc     nbits
        sta     _vbits
        tya
        rts

.segment        "DATA"
min16:  .repeat 17, I
        .byte 16-(I)
        .endrepeat
min8:   .repeat 9, I
        .byte 8-(I)
        .endrepeat
plus8:  .repeat 17, I
        .byte 8+(I)
        .endrepeat
mask:   .byte $FF, $7F, $3F, $1F, $0F, $07, $03, $01, $00
