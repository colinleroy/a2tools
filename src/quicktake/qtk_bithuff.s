;
; File generated by cc65 v 2.19 - Git 51b946bf2
;
        .importzp       c_sp
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, sreg
        .importzp       _prev_ram_irq_vector, _zp4ip

        .import         decsp4, popptr1
        .import         _read
        .import         _cache_start
        .import         _cache_end
        .import         _ifd
        .export         _getbithuff
        .export         _cache

cur_cache_ptr = _prev_ram_irq_vector
_huff_ptr     = _zp4ip

.segment        "BSS"
.align 256
_cache: .res        CACHE_SIZE,$00
_bitbuf: .res 4
_vbits: .res 1
nbits:
        .res        1,$00

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ getbithuff (unsigned char n)
; ---------------------------------------------------------------

.segment        "LC"

inc_cache_high:
        inc     cur_cache_ptr+1
        ldx     cur_cache_ptr+1
        cpx     _cache_end+1
        bne     handle_byte


        ; Push read fd
        jsr     decsp4
        ldy     #$03

        lda     #$00                    ; ifd is never going to be > 255
        sta     (c_sp),y
        dey
        lda     _ifd
        sta     (c_sp),y
        dey

        ; Push buffer
        lda     _cache_start+1
        sta     cur_cache_ptr+1
        sta     (c_sp),y
        dey

        lda     _cache_start
        sta     cur_cache_ptr
        sta     (c_sp),y

        ; Push count (CACHE_SIZE)
        lda     #<CACHE_SIZE
        ldx     #>CACHE_SIZE
        jsr     _read
        clc
        jmp     handle_byte

_getbithuff:
        sta     nbits
        cmp     _vbits
        bcc     have_enough_vbits_h
        ldx     _bitbuf+2
        stx     _bitbuf+3
        ldx     _bitbuf+1
        stx     _bitbuf+2
        ldx     _bitbuf
        stx     _bitbuf+1
        ; _bitbuf low byte will be set below

        ldy     #$00
        lda     (cur_cache_ptr),y
        sta     _bitbuf

        inc     cur_cache_ptr
        lda     cur_cache_ptr
        beq     inc_cache_high

handle_byte:
        lda     _vbits
        clc
        adc     #8
        sta     _vbits

have_enough_vbits_h:
        ldx     _vbits
        lda     min32,x
        cmp     #24
        bcc     maybe_shift_16_h
        ldy     _bitbuf         ; shift 24, take low byte to high
        ldx     #0
        jmp     finish_lshift_h
maybe_shift_16_h:
        cmp     #16
        bcc     maybe_shift_8_h
        ldy     _bitbuf+1       ; shift 16, two low bytes to high
        ldx     _bitbuf
        jmp     finish_lshift_h
maybe_shift_8_h:
        cmp     #8
        bcc     finish_lshift_h
        ldy     _bitbuf+2       ; shift 8, mid bytes to high
        ldx     _bitbuf+1
        ; Don't care about the two low bytes
finish_lshift_h:
        sty     tmp4
        and     #$07
        beq     lshift_done_h
        tay
        txa
        ; We can shift only the two high bytes, they'll be the only ones counting later
:       asl     a
        rol     tmp4
        dey
        bne     :-
        ; And we don't care saving tmp3

lshift_done_h:
        ldx     nbits           ; Now we shift right
        lda     tmp4
        ldy     min8,x
        beq     do_huff_h

:       lsr     a
        dey
        bne     :-
do_huff_h:
        ldy     _huff_ptr+1
        beq     no_huff

        ldx     #$00
        asl     a
        bcc     :+
        inx
        clc

:       adc     _huff_ptr
        sta     ptr1
        txa
        adc     _huff_ptr+1
        sta     ptr1+1
        ldy     #$01
        lda     (ptr1),y
        eor     #$FF
        sec
        adc     _vbits
        sta     _vbits
        ldx     #$00
        dey
        lda     (ptr1),y
        rts
no_huff:
        tax                     ; backup result
        lda     _vbits
        sec
        sbc     nbits
        sta     _vbits
        txa
        ldx     #$00
        rts

.segment        "DATA"
min32:  .byte 32
        .byte 31
        .byte 30
        .byte 29
        .byte 28
        .byte 27
        .byte 26
        .byte 25
        .byte 24
        .byte 23
        .byte 22
        .byte 21
        .byte 20
        .byte 19
        .byte 18
        .byte 17
        .byte 16
        .byte 15
        .byte 14
        .byte 13
        .byte 12
        .byte 11
        .byte 10
        .byte 9
min8:   .byte 8
        .byte 7
        .byte 6
        .byte 5
        .byte 4
        .byte 3
        .byte 2
        .byte 1
        .byte 0
