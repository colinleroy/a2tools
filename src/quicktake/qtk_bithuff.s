;
; File generated by cc65 v 2.19 - Git 51b946bf2
;
        .importzp       sp
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, sreg
        .importzp       _prev_ram_irq_vector

        .import         decsp4, popptr1
        .import         _read
        .import         _bitbuf
        .import         _bitbuf_nohuff
        .import         _vbits
        .import         _cache_start
        .import         _cache_end
        .import         _ifd
        .import         _huff_ptr
        .export         _getbithuff
        .export         _cache

cur_cache_ptr = _prev_ram_irq_vector

.segment        "BSS"
.align 256
_cache: .res        CACHE_SIZE,$00

nbits:
        .res        1,$00

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ getbithuff (unsigned char n)
; ---------------------------------------------------------------

.segment        "LC"

inc_cache_high:
        inc     cur_cache_ptr+1
        ldx     cur_cache_ptr+1
        cpx     _cache_end+1
        bne     handle_byte


        ; Push read fd
        jsr     decsp4
        ldy     #$03

        lda     #$00                    ; ifd is never going to be > 255
        sta     (sp),y
        dey
        lda     _ifd
        sta     (sp),y
        dey

        ; Push buffer
        lda     _cache_start+1
        sta     cur_cache_ptr+1
        sta     (sp),y
        dey

        lda     _cache_start
        sta     cur_cache_ptr
        sta     (sp),y

        ; Push count (CACHE_SIZE)
        lda     #<CACHE_SIZE
        ldx     #>CACHE_SIZE
        jsr     _read
        clc
        bra     handle_byte

_getbithuff:
        sta     nbits
        cmp     _vbits
        bcc     have_enough_vbits_h
        ldx     _bitbuf+2
        stx     _bitbuf+3
        ldx     _bitbuf+1
        stx     _bitbuf+2
        ldx     _bitbuf
        stx     _bitbuf+1
        ; _bitbuf low byte will be set below

        lda     (cur_cache_ptr)
        sta     _bitbuf

        inc     cur_cache_ptr
        lda     cur_cache_ptr
        beq     inc_cache_high

handle_byte:
        ldy     _vbits
        lda     plus8,y
        sta     _vbits

have_enough_vbits_h:
        ldx     _vbits
        lda     min32,x
        cmp     #24
        bcc     maybe_shift_16_h
        ldy     _bitbuf         ; take low byte to high
        ldx     #0
        jmp     finish_lshift_h
maybe_shift_16_h:
        cmp     #16
        bcc     maybe_shift_8_h
        ldy     _bitbuf+1       ; two low bytes to high
        ldx     _bitbuf
        jmp     finish_lshift_h
maybe_shift_8_h:
        cmp     #8
        bcc     finish_lshift_h
        ldy     _bitbuf+2       ; mid bytes to high
        ldx     _bitbuf+1
        ; Don't care about the two low bytes
finish_lshift_h:
        sty     tmp4
        and     #$07
        beq     lshift_done_h
        tay
        txa
        ; We can shift only the two high bytes, they'll be the only ones counting later
:       asl     a
        rol     tmp4
        dey
        bne     :-
        ; And we don't care saving tmp3

lshift_done_h:
        ldx     nbits           ; Now we shift right
        lda     min8,x
        beq     no_final_shift_h
        tay
        lda     tmp4

:       lsr     a
        dey
        bne     :-
        jmp     do_huff_h
no_final_shift_h:
        lda     tmp4
do_huff_h:
        tax                     ; backup for no_huff case
        ldy     _huff_ptr+1
        beq     no_huff

        ldx     #$00
        asl     a
        bcc     :+
        inx
        clc

:       adc     _huff_ptr
        sta     ptr1
        txa
        adc     _huff_ptr+1
        sta     ptr1+1
        ldy     #$01
        lda     (ptr1),y
        eor     #$FF
        sec
        adc     _vbits
        sta     _vbits
        ldx     #$00
        lda     (ptr1)
        rts
no_huff:
        lda     _vbits
        sec
        sbc     nbits
        sta     _vbits
        txa
        ldx     #$00
        rts

.segment        "DATA"
min32:  .byte 32
        .byte 31
        .byte 30
        .byte 29
        .byte 28
        .byte 27
        .byte 26
        .byte 25
        .byte 24
        .byte 23
        .byte 22
        .byte 21
        .byte 20
        .byte 19
        .byte 18
        .byte 17
        .byte 16
        .byte 15
        .byte 14
        .byte 13
        .byte 12
        .byte 11
        .byte 10
        .byte 9
min8:   .byte 8
        .byte 7
        .byte 6
        .byte 5
        .byte 4
        .byte 3
        .byte 2
        .byte 1
        .byte 0

plus8:  .byte 8
        .byte 9
        .byte 10
        .byte 11
        .byte 12
        .byte 13
        .byte 14
        .byte 15
        .byte 16
        .byte 17
        .byte 18
        .byte 19
        .byte 20
        .byte 21
        .byte 22
        .byte 23
        .byte 24
        .byte 25
        .byte 26
        .byte 27
        .byte 28
        .byte 29
        .byte 30
        .byte 31
        .byte 32
        .byte 33
        .byte 34
        .byte 35
        .byte 36
        .byte 37
        .byte 38
        .byte 39
        .byte 40
