;
; File generated by cc65 v 2.19 - Git 51b946bf2
;
        .importzp       c_sp
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, sreg
        .importzp       _prev_ram_irq_vector, _zp4ip

        .import         decsp4, popptr1
        .import         _read
        .import         _cache_start
        .import         _cache_end
        .import         _ifd
        .import         floppy_motor_on
        .export         _huff_num
        .export         _getbithuff
        .export         _cache
        .export         _init_floppy_starter
        .export         _buf_0, _buf_1, _buf_2, _huff_split

cur_cache_ptr = _prev_ram_irq_vector

.segment        "BSS"
.align 256
_cache:        .res        CACHE_SIZE,$00
_buf_0:        .res        $300
_buf_1:        .res        $300
_buf_2:        .res        $300
_huff_split:   .res        19*256*2
CACHE_END = _cache + CACHE_SIZE
.assert <CACHE_END = 0, error

_bitbuf: .res 4
_vbits:  .res 1
nbits:   .res 1,$00
motor_on:.res 1

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ getbithuff (unsigned char n)
; ---------------------------------------------------------------

.segment        "CODE"

_init_floppy_starter:
        lda     floppy_motor_on         ; Patch motor_on if we use a floppy
        beq     :+
        sta     start_floppy_motor+1
        lda     #$C0                    ; Firmware access space
        sta     start_floppy_motor+2
:       rts

inc_cache_high:
        inc     cur_cache_ptr+1
        ldx     cur_cache_ptr+1

        ; Check for cache almost-end and restart floppy
        ; Consider we have time to handle 256b while the
        ; drive restarts
        cpx     #(>CACHE_END)-1
        bne     :+
start_floppy_motor:
        sta     motor_on                 ; Patched if on floppy

:       cpx     #(>CACHE_END)
        bne     inc_vbits


        ; Push read fd
        jsr     decsp4
        ldy     #$03

        lda     #$00                    ; ifd is never going to be > 255
        sta     (c_sp),y
        dey
        lda     _ifd
        sta     (c_sp),y
        dey

        ; Push buffer
        lda     _cache_start+1
        sta     cur_cache_ptr+1
        sta     (c_sp),y
        dey

        lda     _cache_start
        sta     cur_cache_ptr
        sta     (c_sp),y

        ; Push count (CACHE_SIZE)
        lda     #<CACHE_SIZE
        ldx     #>CACHE_SIZE
        jsr     _read
        clc
        jmp     inc_vbits

initbithuff:
        ldx     _bitbuf
        stx     _bitbuf+1
        ; _bitbuf low byte will be set below

        ldy     #$00
        lda     (cur_cache_ptr),y
        sta     _bitbuf

        inc     cur_cache_ptr
        lda     cur_cache_ptr
        beq     inc_cache_high

inc_vbits:
        ldy     _vbits
        ldx     plus8,y
        stx     _vbits
retinc: cpx     #9           ; will be patched with jmp got_vbits
        bcc     initbithuff
        ; Now we're there for the first time, we won't refill more
        ; than one byte at a time. Patch the previous code for
        ; faster return.
        lda     #$4C          ; JMP
        sta     retinc
        lda     #<got_vbits
        sta     retinc+1
        lda     #>got_vbits
        sta     retinc+2
        jmp     got_vbits

_getbithuff:
        sta     nbits
        ldx     _vbits
        cpx     #9
        bcc     initbithuff

got_vbits:
        ldy     min16,x       ; shift = 16-vbits
        lda     _bitbuf+1     ; Load the uint16 bitbuf
        ldx     _bitbuf+0     ; (high byte in A because that's the one we keep)

        stx     tmp4
        cpy     #$00
        beq     lshift_done_h

:       asl     tmp4
        rol     a
        dey
        bne     :-              ; Now we have 0x000AABB0

lshift_done_h:
        ldx     nbits           ; Now we keep the high byte
        ldy     min8,x          ; and do the final shift
        beq     do_huff_h

:       lsr     a
        dey
        bne     :-              ; Final shift done!
do_huff_h:
        ldx     _huff_num
        beq     no_huff
        inx
        stx     ha+2
        tay
        lda     _vbits
        sec
ha:
        sbc     _huff_split+256,y
        sta     _vbits
_huff_num = *+2
        lda     _huff_split,y
        rts
no_huff:
        tax                     ; backup result
        lda     _vbits
        sec
        sbc     nbits
        sta     _vbits
        txa
        rts

.segment        "DATA"
min16:  .repeat 17, I
        .byte 16-(I)
        .endrepeat
min8:   .repeat 9, I
        .byte 8-(I)
        .endrepeat
plus8:  .repeat 17, I
        .byte 8+(I)
        .endrepeat
