;
; File generated by cc65 v 2.19 - Git 51b946bf2
;
        .importzp       c_sp
        .importzp       tmp4
        .importzp       _prev_ram_irq_vector, _zp4ip

        .import         decsp4
        .import         _read
        .import         _cache_start
        .import         _cache_end
        .import         _ifd
        .import         floppy_motor_on
        .export         _huff_num, _huff_num_h
        .export         _getbits6, _getbithuff, _getbithuff36
        .export         _cache
        .export         _init_floppy_starter
        .export         _buf_0, _buf_1, _buf_2, _huff_split
        .importzp       _zp8, _zp9, _zp10, _zp11, _zp12
cur_cache_ptr = _prev_ram_irq_vector

.segment        "BSS"
.align 256
_cache:        .res        CACHE_SIZE,$00
_buf_0:        .res        $400
_buf_1:        .res        $400
_buf_2:        .res        $400
_huff_split:   .res        (18*256*2)+256
CACHE_END = _cache + CACHE_SIZE
.assert <CACHE_END = 0, error

_bitbuf     = _zp8
_next       = _zp9
_vbits      = _zp10
peek        = _zp11
readn       = _zp12
curvbits    = _zp12     ; Shared with readn
motor_on:    .res 1

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ getbithuff (unsigned char n)
; ---------------------------------------------------------------

.segment        "CODE"

_init_floppy_starter:
        ldy     #0                      ; Init bitbuf (consider cache full at very start)
        lda     (cur_cache_ptr),y
        sta     _bitbuf
        iny
        lda     (cur_cache_ptr),y
        sta     _next
        lda     #8
        sta     _vbits

        lda     cur_cache_ptr           ; Init local cache pointer
        clc
        adc     #2                      ; Consider no crossing at very start
        sta     cache_read
        lda     cur_cache_ptr+1
        sta     cache_read+1

        lda     floppy_motor_on         ; Patch motor_on if we use a floppy
        beq     :+
        sta     start_floppy_motor+1
        lda     #$C0                    ; Firmware access space
        sta     start_floppy_motor+2
:       rts

; refill is optimised to go back as fast as possible to
; getbithuff (which is hotter than getbit6 and getbithuff36,
; called respectively 200000, 5000, 360 times). Instead of
; using jsr with a 6-cycle penalty compared to double-jmps,
; we'll use double-jmps, and update the return jmp target
; before and after getbits6/huff36.
.macro UPDATE_REFILL_RET addr
        ldx    #<addr
        stx    refillret+1
        ldx    #>addr
        stx    refillret+2
.endmacro
refill6:
        UPDATE_REFILL_RET cont6
        jmp    refill
cont6:  UPDATE_REFILL_RET conth
        jmp    contgb6

_getbits6:
        lda    #0
        ldy    #6
:       dec    _vbits
        bmi    refill6
contgb6:asl    _bitbuf
        rol    a
        dey
        bne    :-
        rts

_getbithuff:
        lda    #0             ; r = 0
        sta    readn          ; n = 0

:       inc    readn          ; Read until valid code
        dec    _vbits
        bmi    refill
conth:  asl    _bitbuf
        rol    a
        tax

_huff_num_h = *+2             ; Get num bits
        ldy     _huff_split+256,x
        cpy     readn
        bne    :-

_huff_num = *+2
        lda     _huff_split,x
        rts

; Must never destroy A or Y
refill:
        ldx     _next
        stx     _bitbuf

cache_read = *+1
        ldx     $FFFF
        stx     _next

        ldx     #7
        stx     _vbits

        inc     cache_read
        beq     inc_cache_high
refillret:
        jmp     $FFFF

inc_cache_high:
        inc     cache_read+1
        ldx     cache_read+1

        ; Check for cache almost-end and restart floppy
        ; Consider we have time to handle 256b while the
        ; drive restarts
        cpx     #(>CACHE_END)-1
        bcc     refillret

start_floppy_motor:
        sta     motor_on                 ; Patched if on floppy

        cpx     #(>CACHE_END)
        bne     refillret
do_read:
        sty     ybck
        sta     abck
        ; Push read fd
        jsr     decsp4
        ldy     #$03

        lda     #$00                    ; ifd is never going to be > 255
        sta     (c_sp),y
        dey
        lda     _ifd
        sta     (c_sp),y
        dey

        ; Push buffer
        lda     _cache_start+1
        sta     cache_read+1
        sta     (c_sp),y
        dey

        lda     _cache_start
        sta     cache_read
        sta     (c_sp),y

        ; Push count (CACHE_SIZE)
        lda     #<CACHE_SIZE
        ldx     #>CACHE_SIZE
        jsr     _read
        clc
ybck = *+1
        ldy     #$FF
abck = *+1
        lda     #$FF
        jmp     refillret

refill36:
        UPDATE_REFILL_RET cont36
        jmp    refill
cont36: UPDATE_REFILL_RET conth
        jmp    contgb36

_getbithuff36:
        lda    #0             ; Read and consume 5 bits
        ldy    #5
:       dec    _vbits
        bmi    refill36
contgb36:
        asl    _bitbuf
        rol    a
        dey
        bne    :-

        ldx    _vbits
        stx    curvbits

        ldx    _bitbuf        ; Now peek next 3 bits
        stx    peek

        asl    peek           ; One,
        rol    a

        dec    curvbits
        bne    :+
        ldx    _next
        stx    peek

:       asl    peek           ; Two,
        rol    a

        dec    curvbits
        bne    :+
        ldx    _next
        stx    peek

:       asl    peek           ; Three
        rol    a

        tax                   ; We done
        lda    _huff_split+36*256,x
        rts
