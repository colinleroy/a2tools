;
; File generated by cc65 v 2.19 - Git 51b946bf2
;
        .importzp       c_sp
        .importzp       tmp4
        .importzp       _prev_ram_irq_vector, _zp4ip

        .import         decsp4
        .import         _read
        .import         _cache_start
        .import         _cache_end
        .import         _ifd
        .import         floppy_motor_on
        .export         _huff_numc, _huff_numc_h
        .export         _huff_numd, _huff_numd_h
        .export         _huff_numdd
        .export         _getbits6, _getctrlhuff, _getdatahuff, _getdatahuff8
        .export         _discarddatahuff, _discard4datahuff8
        .export         _cache
        .export         _init_floppy_starter
        .export         _next_line_l, _next_line_h
        .export         _raw_image, _huff_ctrl, _huff_data
        .export         _ushiftl3p4, _ushiftl4, _sshiftl4, _ushiftr4
        .export         _div48_l
        .export         _dyndiv_l
        .importzp       _zp8, _zp9, _zp10, _zp11, _zp12
cur_cache_ptr = _prev_ram_irq_vector

.segment        "BSS"
.align 256
_cache:        .res        CACHE_SIZE,$00
CACHE_END = _cache + CACHE_SIZE
.assert <CACHE_END = 0, error

_next_line_l:  .res        322
_ushiftl3p4:   .res        32
free1:         .res        158

_ushiftl4:     .res        256
_sshiftl4:     .res        256
_ushiftr4:     .res        256

.assert <* = 0, error

_huff_ctrl:   .res        (9*256*2)
_huff_data:   .res        (9*256)
_div48_l:     .res        256
_dyndiv_l:    .res        256
.assert <* = 0, error
_raw_image:   .res        (20*320)  ; Cool, this is aligned!
.assert <* = 0, error
_next_line_h:  .res        322

_bitbuf     = _zp8
readn       = _zp9
_vbits      = _zp10
motor_on:    .res 1

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ getbithuff (unsigned char n)
; ---------------------------------------------------------------

.segment        "CODE"

_init_floppy_starter:
        ldy     #0                      ; Init bitbuf (consider cache full at very start)
        lda     (cur_cache_ptr),y
        sta     _bitbuf
        lda     #8
        sta     _vbits

        ldx     cur_cache_ptr           ; Init local cache pointer
        inx                             ; Consider no crossing at very start
        stx     cache_read
        ldx     cur_cache_ptr+1
        stx     cache_read+1

        lda     floppy_motor_on         ; Patch motor_on if we use a floppy
        beq     :+
        sta     start_floppy_motor+1
        lda     #$C0                    ; Firmware access space
        sta     start_floppy_motor+2
:       rts

; Returns value in A
_getbits6:
        lda    #0
        ldy    #6
        ldx     _vbits
:       dex
        bpl    :+
        jsr    refill
:       asl    _bitbuf
        rol    a
        dey
        bne    :--
        stx     _vbits
        rts

ctrl_refill:
        jsr     refill
        jmp     ctrl_cont
; Returns value in A
_getctrlhuff:
        lda    #0             ; r = 0
        tay                   ; n = 0
        ldx     _vbits

:       iny                   ; Read until valid code
        dex
        bmi     ctrl_refill
ctrl_cont:
        asl     _bitbuf
        rol     a
        sta     bitscheckc+1    ; Patch bitcheck address
                              ; cpy $nnnn,x is impossible so this is faster

bitscheckc:
_huff_numc = *+2             ; Get num bits
        cpy     _huff_ctrl
        bne     :-
        stx     _vbits

        tax
_huff_numc_h = *+2
        lda     _huff_ctrl+256,x
        rts

data_refill:
        jsr     refill
        jmp     data_cont

; Returns value in X
; _huff_data is a 256 bytes array with [0-127] containing the number of bits of each code,
; as reading binary 10 is not the same as 010 for the Huffman encoding, and [128]-[255]
; contains the value of each code.
; There are multiple (aligned)huff arrays and the high byte addresses are patched by caller.
_getdatahuff:
        lda     #0            ; huff code = 0
        tay                   ; numbits read = 0

        ldx     _vbits        ; How many remaining bits in the buffer?
:       iny                   ; Count read bit
        dex                   ; Remove from buffer remaining
        bmi     data_refill   ; Go refill buffer if empty - comes back to data_cont
data_cont:
        asl     _bitbuf       ; Get bit into carry
        rol     a             ; Put it into huff code

        sta     _huff_numd-1  ; Patch bitcheck address right below (the array is
                              ; aligned, so that makes an ad-hoc tax / cpy $nnnn,x)

_huff_numd = *+2              ; Is this code valid with this number of bits?
        cpy     _huff_data    ; (for example, 10 is not the same as 010!)
        bne    :-             ; Nope. Go read another bit

        stx    _vbits         ; Valid code. Save remaining
        tay                   ; And get value
_huff_numd_h = *+2
        ldx     _huff_data+128,y
        rts

discarddata_refill:
        jsr     refill
        jmp     discarddata_cont

; Returns nothing, discards X tokens
_discarddatahuff:
        stx     num_discard

discard_token:
        lda     #0             ; r = 0
        tay                   ; n = 0

        ldx     _vbits
:       iny                   ; Read until valid code
        dex
        bmi     discarddata_refill
discarddata_cont:
        asl     _bitbuf
        rol     a
        sta     _huff_numdd-1 ; Patch bitcheck address
                              ; cpy $nnnn,x is impossible so this is faster

_huff_numdd = *+2             ; Get num bits
        cpy     _huff_data
        bne    :-

        stx     _vbits

        dec     num_discard
        bne     discard_token
        rts

; Returns value in A
_getdatahuff8:
        lda     #0             ; Read and consume 5 bits
        ldy     #5
        ldx     _vbits
:       dex
        bpl     :+
        jsr     refill
:       asl     _bitbuf
        rol     a
        dey
        bne     :--

        stx     _vbits
        tax
        lda    _ushiftl3p4,x
        rts

; Returns nothing, discards 4 5-bit tokens
; TODO: don't shift all bits, skip full bytes
; Not too urgent as function is called ~30 times
; and accounts for less than 20k cycles total
_discard4datahuff8:
        ldy     #20
        ldx     _vbits
:       dex
        bpl     :+
        jsr     refill
:       asl     _bitbuf
        dey
        bne     :--
        stx     _vbits

        rts

; Must never destroy A or Y
refill:
cache_read = *+1
        ldx     $FFFF             ; 4
        stx     _bitbuf           ; 7

        ldx     #7                ; 9
        stx     _vbits            ; 12

        inc     cache_read        ; 17
        beq     inc_cache_high    ; 19  20
        rts

inc_cache_high:
        inc     cache_read+1      ;     25
        ldx     cache_read+1      ;     27

        ; Check for cache almost-end and restart floppy
        ; Consider we have time to handle 256b while the
        ; drive restarts
        cpx     #(>CACHE_END)-4   ;     29
        bcs     start_floppy_motor;     31  32
        ldx     #7                ; Reload vbits
        rts

start_floppy_motor:
        sta     motor_on                 ; Patched if on floppy

        cpx     #(>CACHE_END)
        beq     do_read
        ldx     #7                ; Reload vbits
        rts
do_read:
        sty     ybck
        sta     abck
        ; Push read fd
        jsr     decsp4
        ldy     #$03

        lda     #$00                    ; ifd is never going to be > 255
        sta     (c_sp),y
        dey
        lda     _ifd
        sta     (c_sp),y
        dey

        ; Push buffer
        lda     _cache_start+1
        sta     cache_read+1
        sta     (c_sp),y
        dey

        lda     _cache_start
        sta     cache_read
        sta     (c_sp),y

        ; Push count (CACHE_SIZE)
        lda     #<CACHE_SIZE
        ldx     #>CACHE_SIZE
        jsr     _read
        clc
ybck = *+1
        ldy     #$FF
abck = *+1
        lda     #$FF
        ldx     #7                ; Reload vbits
        rts

.segment "BSS"
num_discard:    .res 1
