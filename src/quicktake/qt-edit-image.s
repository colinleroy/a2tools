;
; File generated by cc65 v 2.19 - Git 6efe447d1
;
	.fopt		compiler,"cc65 v 2.19 - Git 6efe447d1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	c_sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_tolower
	.import		_printf
	.import		_snprintf
	.import		_free
	.import		_strcat
	.import		_strcmp
	.import		_strcpy
	.import		_strrchr
	.import		_bzero
	.import		_write
	.import		_read
	.import		_lseek
	.import		_exec
	.import		_open
	.import		_close
	.import		_dget_text_single
	.import		__filetype
	.import		__auxtype
	.import		_clrscr
	.import		_gotox
	.import		_wherex
	.import		_wherey
	.import		_cputs
	.import		_cgetc
	.import		_file_select
	.import		_init_graphics
	.import		_init_text
	.import		_backup_screen_holes
	.import		_hgr_mix_is_on
	.import		_hgr_mixon
	.import		_hgr_mixoff
	.import		_hgr_baseaddr_l
	.import		_hgr_baseaddr_h
	.import		_init_hgr_base_addrs
	.import		_reopen_start_device
	.import		_progress_bar
	.import		_set_scrollwindow
	.importzp	_zp6
	.importzp	_zp2p
	.importzp	_zp8p
	.importzp	_zp10p
	.export		_ifd
	.import		_magic
	.export		_qt_convert_image
	.export		_qt_edit_image
	.export		_qt_view_image
	.export		_dither_to_hgr
	.import		_buffer
	.import		_state_set
	.import		_scrw
	.import		_scrh
	.export		_ofd
	.export		_angle
	.export		_auto_level
	.export		_dither_alg
	.export		_resize
	.export		_cropping
	.export		_zoom_level
	.export		_crop_start_x
	.export		_crop_end_x
	.export		_crop_start_y
	.export		_crop_end_y
	.export		_brighten
	.export		_x_offset
	.export		_crop_pos
	.export		_is_horiz
	.export		_qt_convert_image_with_crop
	.export		_err_buf
	.export		_opt_histogram
	.export		_bayer_map
	.export		_file_width
	.export		_file_height
	.export		_is_thumb
	.export		_is_qt100
	.export		_first_byte_idx
	.export		_off_y
	.export		_off_x
	.export		_end_dx
	.export		_bayer_map_x
	.export		_bayer_map_y
	.export		_end_bayer_map_x
	.export		_end_bayer_map_y
	.export		_cur_buf_page
	.export		_y
	.export		_dy
	.export		_cur_hgr_row
	.export		_cur_hgr_mod
	.export		_load_thumbnail_data
	.import		_do_dither_horiz
	.import		_do_dither_vert

.segment	"DATA"

_angle:
	.word	$0000
_auto_level:
	.byte	$01
_dither_alg:
	.byte	$00
_resize:
	.byte	$01
_cropping:
	.byte	$00
_zoom_level:
	.byte	$00
_crop_start_x:
	.word	$0000
_crop_start_y:
	.word	$0000
_brighten:
	.byte	$00
_crop_pos:
	.byte	$01
_is_horiz:
	.byte	$00
_bayer_map:
	.byte	$80
	.byte	$00
	.byte	$A0
	.byte	$20
	.byte	$88
	.byte	$08
	.byte	$A8
	.byte	$28
	.byte	$40
	.byte	$C0
	.byte	$60
	.byte	$E0
	.byte	$48
	.byte	$C8
	.byte	$68
	.byte	$E8
	.byte	$B0
	.byte	$30
	.byte	$90
	.byte	$10
	.byte	$B8
	.byte	$38
	.byte	$98
	.byte	$18
	.byte	$70
	.byte	$F0
	.byte	$50
	.byte	$D0
	.byte	$78
	.byte	$F8
	.byte	$58
	.byte	$D8
	.byte	$8C
	.byte	$0C
	.byte	$AC
	.byte	$2C
	.byte	$84
	.byte	$04
	.byte	$A4
	.byte	$24
	.byte	$4C
	.byte	$CC
	.byte	$6C
	.byte	$EC
	.byte	$44
	.byte	$C4
	.byte	$64
	.byte	$E4
	.byte	$BC
	.byte	$3C
	.byte	$9C
	.byte	$1C
	.byte	$B4
	.byte	$34
	.byte	$94
	.byte	$14
	.byte	$7C
	.byte	$FC
	.byte	$5C
	.byte	$DC
	.byte	$74
	.byte	$F4
	.byte	$54
	.byte	$D4

.segment	"RODATA"

S009D:
	.byte	$44,$69,$74,$68,$65,$72,$20,$77,$69,$74,$68,$20,$45,$3A,$20,$53
	.byte	$69,$65,$72,$72,$61,$20,$4C,$69,$74,$65,$20,$2F,$20,$59,$3A,$20
	.byte	$42,$61,$79,$65,$72,$20,$2F,$20,$4E,$3A,$20,$4E,$6F,$20,$64,$69
	.byte	$74,$68,$65,$72,$20,$28,$43,$75,$72,$72,$65,$6E,$74,$3A,$20,$25
	.byte	$73,$29,$0A,$53,$3A,$20,$53,$61,$76,$65,$20,$2D,$20,$45,$73,$63
	.byte	$61,$70,$65,$3A,$20,$45,$78,$69,$74,$20,$2D,$20,$41,$6E,$79,$20
	.byte	$6F,$74,$68,$65,$72,$20,$6B,$65,$79,$3A,$20,$48,$69,$64,$65,$20
	.byte	$68,$65,$6C,$70,$00
S00A4:
	.byte	$41,$72,$72,$6F,$77,$20,$6B,$65,$79,$73,$3A,$20,$4D,$6F,$76,$65
	.byte	$20,$73,$65,$6C,$65,$63,$74,$69,$6F,$6E,$0D,$0A,$45,$6E,$74,$65
	.byte	$72,$3A,$20,$52,$65,$66,$72,$61,$6D,$65,$3B,$20,$45,$73,$63,$61
	.byte	$70,$65,$3A,$20,$43,$61,$6E,$63,$65,$6C,$00
S0098:
	.byte	$0A,$48,$3A,$20,$41,$75,$74,$6F,$2D,$6C,$65,$76,$65,$6C,$20,$25
	.byte	$73,$3B,$20,$42,$3A,$20,$42,$72,$69,$67,$68,$74,$65,$6E,$20,$2D
	.byte	$20,$44,$3A,$20,$44,$61,$72,$6B,$65,$6E,$20,$28,$43,$75,$72,$72
	.byte	$65,$6E,$74,$20,$25,$73,$25,$64,$29,$0A,$00
S00A9:
	.byte	$50,$6C,$65,$61,$73,$65,$20,$69,$6E,$73,$65,$72,$74,$20,$69,$6D
	.byte	$61,$67,$65,$20,$66,$6C,$6F,$70,$70,$79,$20,$66,$6F,$72,$20,$25
	.byte	$73,$2C,$20,$6F,$72,$20,$45,$73,$63,$61,$70,$65,$20,$74,$6F,$20
	.byte	$72,$65,$74,$75,$72,$6E,$0A,$00
S00CF:
	.byte	$52,$65,$6E,$64,$65,$72,$69,$6E,$67,$2E,$2E,$2E,$20,$28,$50,$72
	.byte	$65,$73,$73,$20,$73,$70,$61,$63,$65,$20,$74,$6F,$20,$74,$6F,$67
	.byte	$67,$6C,$65,$20,$6D,$65,$6E,$75,$20,$6F,$6E,$63,$65,$20,$64,$6F
	.byte	$6E,$65,$2E,$29,$0D,$0A,$00
S00AC:
	.byte	$44,$6F,$6E,$65,$2E,$20,$47,$6F,$20,$62,$61,$63,$6B,$20,$74,$6F
	.byte	$20,$45,$64,$69,$74,$69,$6F,$6E,$2C,$20,$56,$69,$65,$77,$2C,$20
	.byte	$6F,$72,$20,$6D,$61,$69,$6E,$20,$4D,$65,$6E,$75,$3F,$20,$28,$45
	.byte	$2F,$76,$2F,$6D,$29,$00
S00AB:
	.byte	$0A,$45,$72,$72,$6F,$72,$2E,$20,$50,$72,$65,$73,$73,$20,$61,$20
	.byte	$6B,$65,$79,$20,$74,$6F,$20,$63,$6F,$6E,$74,$69,$6E,$75,$65,$2E
	.byte	$2E,$2E,$0A,$00
S0094:
	.byte	$52,$6F,$74,$61,$74,$65,$3A,$20,$4C,$3A,$6C,$65,$66,$74,$20,$2D
	.byte	$20,$55,$3A,$31,$38,$30,$20,$2D,$20,$52,$3A,$72,$69,$67,$68,$74
	.byte	$00
S0090:
	.byte	$63,$72,$6F,$70,$20,$25,$64,$2D,$25,$64,$2C,$20,$64,$73,$78,$20
	.byte	$25,$64,$2D,$25,$64,$2C,$20,$6C,$78,$20,$25,$64,$2D,$25,$64,$0A
	.byte	$00
S0096:
	.byte	$3B,$20,$43,$3A,$20,$46,$69,$74,$20,$2D,$20,$55,$70,$2F,$64,$6F
	.byte	$77,$6E,$3A,$20,$41,$64,$6A,$75,$73,$74,$20,$63,$72,$6F,$70,$00
S00CD:
	.byte	$43,$6F,$6E,$76,$65,$72,$74,$69,$6E,$67,$20,$25,$73,$20,$28,$45
	.byte	$73,$63,$20,$74,$6F,$20,$73,$74,$6F,$70,$29,$2E,$2E,$2E,$0A,$00
S004D:
	.byte	$48,$69,$73,$74,$6F,$67,$72,$61,$6D,$20,$65,$71,$75,$61,$6C,$69
	.byte	$7A,$61,$74,$69,$6F,$6E,$2E,$2E,$2E,$0D,$0A,$00
S00A2:
	.byte	$45,$78,$69,$74,$20,$77,$69,$74,$68,$6F,$75,$74,$20,$73,$61,$76
	.byte	$69,$6E,$67,$3F,$20,$28,$79,$2F,$4E,$29,$00
S00A3:
	.byte	$2B,$3A,$20,$5A,$6F,$6F,$6D,$20,$69,$6E,$3B,$20,$2D,$3A,$20,$5A
	.byte	$6F,$6F,$6D,$20,$6F,$75,$74,$3B,$20,$00
S004B:
	.byte	$0D,$0A,$55,$6E,$6B,$6E,$6F,$77,$6E,$20,$66,$69,$6C,$65,$20,$74
	.byte	$79,$70,$65,$2E,$0D,$0A,$00
S0041:
	.byte	$49,$6D,$61,$67,$65,$20,$63,$6F,$6E,$76,$65,$72,$73,$69,$6F,$6E
	.byte	$0D,$0A,$0D,$0A,$00
S0043:
	.byte	$53,$65,$6C,$65,$63,$74,$20,$61,$6E,$20,$69,$6D,$61,$67,$65,$20
	.byte	$66,$69,$6C,$65,$00
S00D7:
	.byte	$5F,$5F,$5F,$53,$45,$4C,$5F,$5F,$5F,$20,$73,$6C,$6F,$77,$74,$61
	.byte	$6B,$65,$00
S00CE:
	.byte	$43,$61,$6E,$27,$74,$20,$6F,$70,$65,$6E,$20,$25,$73,$0A,$00
S0044:
	.byte	$25,$73,$20,$25,$64,$20,$25,$64,$20,$25,$64,$20,$25,$64,$00
S0097:
	.byte	$3B,$20,$43,$3A,$20,$52,$65,$66,$72,$61,$6D,$65,$00
S00A0:
	.byte	$53,$69,$65,$72,$72,$61,$20,$4C,$69,$74,$65,$00
S00D5:
	.byte	$25,$73,$20,$73,$6C,$6F,$77,$74,$61,$6B,$65,$00
S004C:
	.byte	$2F,$52,$41,$4D,$2F,$48,$49,$53,$54,$00
S0095:
	.byte	$3B,$20,$43,$3A,$20,$43,$72,$6F,$70,$00
S00D4:
	.byte	$2F,$52,$41,$4D,$2F,$47,$52,$45,$59,$00
S00AA:
	.byte	$53,$61,$76,$69,$6E,$67,$2E,$2E,$2E,$00
S00A8:
	.byte	$53,$61,$76,$65,$20,$74,$6F,$3A,$20,$00
S0046:
	.byte	$71,$74,$6B,$74,$63,$6F,$6E,$76,$00
S004A:
	.byte	$6A,$70,$65,$67,$63,$6F,$6E,$76,$00
S0048:
	.byte	$71,$74,$6B,$6E,$63,$6F,$6E,$76,$00
S0042:
	.byte	$49,$6D,$61,$67,$65,$3A,$20,$00
S00D9:
	.byte	$69,$6D,$67,$76,$69,$65,$77,$00
S009F:
	.byte	$42,$61,$79,$65,$72,$00
S00A6:
	.byte	$2E,$64,$68,$67,$72,$00
S0049:
	.byte	$FF,$D8,$FF,$E1,$00
S0047:
	.byte	$71,$6B,$74,$6E,$00
S00A7:
	.byte	$2E,$68,$67,$72,$00
S00A1:
	.byte	$4E,$6F,$6E,$65,$00
S0045:
	.byte	$71,$6B,$74,$6B,$00
S0099:
	.byte	$6F,$66,$66,$00
S009A:
	.byte	$6F,$6E,$00
S009B:
	.byte	$2B,$00
S009C	:=	S009D+116

.segment	"BSS"

_ifd:
	.res	2,$00
_ofd:
	.res	2,$00
_crop_end_x:
	.res	2,$00
_crop_end_y:
	.res	2,$00
_x_offset:
	.res	1,$00
_imgname:
	.res	65,$00
_args:
	.res	81,$00
_err_buf:
	.res	1032,$00
_opt_histogram:
	.res	256,$00
_thumb_buf:
	.res	160,$00
_file_width:
	.res	2,$00
_file_height:
	.res	1,$00
_is_thumb:
	.res	1,$00
_is_qt100:
	.res	1,$00
_first_byte_idx:
	.res	1,$00
_off_y:
	.res	2,$00
_off_x:
	.res	1,$00
_end_dx:
	.res	1,$00
_bayer_map_x:
	.res	1,$00
_bayer_map_y:
	.res	1,$00
_end_bayer_map_x:
	.res	1,$00
_end_bayer_map_y:
	.res	1,$00
_cur_buf_page:
	.res	2,$00
_y:
	.res	1,$00
_dy:
	.res	2,$00
_cur_hgr_row:
	.res	1,$00
_cur_hgr_mod:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ qt_convert_image (const char *filename)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_qt_convert_image: near

.segment	"CODE"

;
; void qt_convert_image(const char *filename) {
;
	jsr     pushax
;
; qt_convert_image_with_crop(filename, 0, 0, 640, 480);
;
	jsr     pushw0sp
	jsr     push0
	jsr     push0
	ldx     #$02
	lda     #$80
	jsr     pushax
	dex
	lda     #$E0
	jsr     _qt_convert_image_with_crop
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ qt_edit_image (const char *ofname, unsigned int src_width)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_qt_edit_image: near

.segment	"CODE"

;
; void qt_edit_image(const char *ofname, uint16 src_width) {
;
	jsr     pushax
;
; set_scrollwindow(20, scrh);
;
	lda     #$14
	jsr     pusha
	lda     _scrh
	jsr     _set_scrollwindow
;
; if (angle >= 360)
;
L0002:	lda     _angle
	cmp     #$68
	lda     _angle+1
	sbc     #$01
	bvs     L0006
	eor     #$80
L0006:	bpl     L0005
;
; angle -= 360;
;
	lda     _angle
	sec
	sbc     #$68
	sta     _angle
	lda     _angle+1
	sbc     #$01
	sta     _angle+1
;
; if (angle < 0)
;
L0005:	ldx     _angle+1
	cpx     #$80
	bcc     L0007
;
; angle += 360;
;
	lda     #$68
	clc
	adc     _angle
	sta     _angle
	lda     #$01
	adc     _angle+1
	sta     _angle+1
;
; dither_to_hgr(TMP_NAME, ofname, FILE_WIDTH, FILE_HEIGHT, QT_MODEL_UNKNOWN);
;
L0007:	lda     #<(S00D4)
	ldx     #>(S00D4)
	jsr     pushax
	ldy     #$07
	jsr     pushwysp
	ldx     #$01
	lda     #$00
	jsr     pushax
	lda     #$C0
	jsr     pusha0
	lda     #$00
	jsr     _dither_to_hgr
;
; } while (reedit_image(ofname, src_width));
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$03
	jsr     ldaxysp
	jsr     _reedit_image
	tax
	bne     L0002
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ qt_view_image (const char *filename)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_qt_view_image: near

.segment	"CODE"

;
; uint8 qt_view_image(const char *filename) {
;
	jsr     pushax
;
; if (filename)
;
	ldy     #$01
	lda     (c_sp),y
	dey
	ora     (c_sp),y
	beq     L0002
;
; snprintf((char *)args, sizeof(args) - 1, "%s "PROGRAM_NAME, filename);
;
	lda     #<(_args)
	ldx     #>(_args)
	jsr     pushax
	lda     #$50
	jsr     pusha0
	lda     #<(S00D5)
	ldx     #>(S00D5)
	jsr     pushax
	ldy     #$09
	jsr     pushwysp
	ldy     #$08
;
; else
;
	jmp     L0004
;
; snprintf((char *)args, sizeof(args) - 1, "___SEL___ "PROGRAM_NAME);
;
L0002:	lda     #<(_args)
	ldx     #>(_args)
	jsr     pushax
	lda     #$50
	jsr     pusha0
	lda     #<(S00D7)
	ldx     #>(S00D7)
	jsr     pushax
	ldy     #$06
L0004:	jsr     _snprintf
;
; init_text();
;
	jsr     _init_text
;
; return exec("imgview", (char *)args);
;
	lda     #<(S00D9)
	ldx     #>(S00D9)
	jsr     pushax
	lda     #<(_args)
	ldx     #>(_args)
	jsr     _exec
	ldx     #$00
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ dither_to_hgr (const char *ifname, const char *ofname, unsigned int p_width, unsigned int p_height, unsigned char serial_model)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_dither_to_hgr: near

.segment	"CODE"

;
; void dither_to_hgr(const char *ifname, const char *ofname, uint16 p_width, uint16 p_height, uint8 serial_model) {
;
	jsr     pusha
;
; is_thumb = (p_width == THUMB_WIDTH*2);
;
	ldy     #$04
	lda     (c_sp),y
	tax
	dey
	lda     (c_sp),y
	cpx     #$00
	bne     L0002
	cmp     #$A0
L0002:	jsr     booleq
	sta     _is_thumb
;
; is_qt100 = (serial_model == QT_MODEL_100);
;
	lda     (c_sp,x)
	cmp     #$64
	jsr     booleq
	sta     _is_qt100
;
; file_width = p_width;
;
	iny
	lda     (c_sp),y
	sta     _file_width+1
	dey
	lda     (c_sp),y
	sta     _file_width
;
; file_height = p_height;
;
	ldy     #$01
	lda     (c_sp),y
	sta     _file_height
;
; x_offset = ((HGR_WIDTH - file_width) / 2);
;
	lda     #$18
	sec
	sbc     _file_width
	pha
	tya
	sbc     _file_width+1
	tax
	pla
	jsr     shrax1
	sta     _x_offset
;
; init_data();
;
	jsr     _init_data
;
; clrscr();
;
	jsr     _clrscr
;
; printf("Converting %s (Esc to stop)...\n", ofname);
;
	lda     #<(S00CD)
	ldx     #>(S00CD)
	jsr     pushax
	ldy     #$0A
	jsr     pushwysp
	ldy     #$04
	jsr     _printf
;
; ifd = open(ifname, O_RDONLY);
;
	jsr     decsp4
	ldy     #$0C
	lda     (c_sp),y
	tax
	dey
	lda     (c_sp),y
	ldy     #$02
	sta     (c_sp),y
	iny
	txa
	sta     (c_sp),y
	lda     #$01
	ldy     #$00
	sta     (c_sp),y
	iny
	lda     #$00
	sta     (c_sp),y
	ldy     #$04
	jsr     _open
	sta     _ifd
	stx     _ifd+1
;
; if (ifd <= 0) {
;
	cmp     #$01
	txa
	sbc     #$00
	bvc     L0004
	eor     #$80
L0004:	bpl     L0003
;
; printf("Can't open %s\n", ifname);
;
	lda     #<(S00CE)
	ldx     #>(S00CE)
	jsr     pushax
	ldy     #$0C
	jsr     pushwysp
	ldy     #$04
	jsr     _printf
;
; return;
;
	jmp     L0001
;
; if (is_thumb) {
;
L0003:	lda     _is_thumb
	beq     L0005
;
; thumb_histogram(ifd);
;
	lda     _ifd
	ldx     _ifd+1
	jsr     _thumb_histogram
;
; lseek(ifd, 0, SEEK_SET);
;
	jsr     decsp6
	lda     _ifd
	ldy     #$04
	sta     (c_sp),y
	iny
	lda     _ifd+1
	sta     (c_sp),y
	lda     #$00
	tay
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	tax
	lda     #$02
	jsr     _lseek
;
; dither_alg = DITHER_BAYER;
;
	lda     #$01
	sta     _dither_alg
;
; hgr_mixon();
;
L0005:	jsr     _hgr_mixon
;
; cputs("Rendering... (Press space to toggle menu once done.)\r\n");
;
	lda     #<(S00CF)
	ldx     #>(S00CF)
	jsr     _cputs
;
; progress_bar(wherex(), wherey(), scrw, 0, file_height);
;
	ldy     #$0A
	jsr     subysp
	jsr     _wherex
	ldy     #$08
	sta     (c_sp),y
	iny
	txa
	sta     (c_sp),y
	jsr     _wherey
	ldy     #$06
	sta     (c_sp),y
	iny
	txa
	sta     (c_sp),y
	lda     _scrw
	ldy     #$04
	sta     (c_sp),y
	iny
	lda     #$00
	sta     (c_sp),y
	tay
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	tax
	lda     _file_height
	stx     sreg
	stx     sreg+1
	jsr     _progress_bar
;
; bzero(err_buf, sizeof err_buf);
;
	lda     #<(_err_buf)
	ldx     #>(_err_buf)
	jsr     pushax
	ldx     #$04
	lda     #$08
	jsr     _bzero
;
; if (angle == 0 || angle == 180) {
;
	lda     _angle
	ora     _angle+1
	beq     L0008
	lda     _angle+1
	bne     L000F
	lda     _angle
	cmp     #$B4
	beq     L0008
L000F:	lda     #$00
	jmp     L000E
;
; is_horiz = 1;
;
L0008:	lda     #$01
	sta     _is_horiz
;
; init_graphics(1, 1);
;
	jsr     pusha
	jsr     _init_graphics
;
; hgr_mixon();
;
	jsr     _hgr_mixon
;
; do_dither_horiz();
;
	jsr     _do_dither_horiz
;
; } else {
;
	jmp     L000B
;
; is_horiz = 0;
;
L000E:	sta     _is_horiz
;
; init_graphics(1, 1);
;
	lda     #$01
	jsr     pusha
	jsr     _init_graphics
;
; hgr_mixon();
;
	jsr     _hgr_mixon
;
; do_dither_vert();
;
	jsr     _do_dither_vert
;
; progress_bar(-1, -1, scrw, file_height, file_height);
;
L000B:	ldy     #$0A
	jsr     subysp
	lda     #$FF
	ldy     #$08
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	ldy     #$06
	sta     (c_sp),y
	iny
	sta     (c_sp),y
	lda     _scrw
	ldy     #$04
	sta     (c_sp),y
	iny
	lda     #$00
	sta     (c_sp),y
	tax
	lda     _file_height
	stx     sreg
	stx     sreg+1
	jsr     steax0sp
	lda     _file_height
	jsr     _progress_bar
;
; if (!is_thumb) {
;
	lda     _is_thumb
	bne     L000C
;
; hgr_mixoff();
;
	jsr     _hgr_mixoff
;
; close(ifd);
;
L000C:	lda     _ifd
	ldx     _ifd+1
	jsr     _close
;
; }
;
L0001:	ldy     #$09
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; void __near__ qt_convert_image_with_crop (const char *filename, unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_qt_convert_image_with_crop: near

.segment	"CODE"

;
; void qt_convert_image_with_crop(const char *filename, uint16 sx, uint16 sy, uint16 ex, uint16 ey) {
;
	jsr     pushax
;
; set_scrollwindow(0, scrh);
;
	lda     #$00
	jsr     pusha
	lda     _scrh
	jsr     _set_scrollwindow
;
; clrscr();
;
	jsr     _clrscr
;
; cputs("Image conversion\r\n\r\n");
;
	lda     #<(S0041)
	ldx     #>(S0041)
	jsr     _cputs
;
; if (!filename) {
;
	ldy     #$09
	lda     (c_sp),y
	dey
	ora     (c_sp),y
	bne     L0002
;
; cputs("Image: ");
;
	lda     #<(S0042)
	ldx     #>(S0042)
	jsr     _cputs
;
; tmp = file_select(0, "Select an image file");
;
	lda     #$00
	jsr     pusha
	lda     #<(S0043)
	ldx     #>(S0043)
	jsr     _file_select
	sta     M0001
	stx     M0001+1
;
; if (tmp == NULL)
;
	cpx     #$00
	bne     L000F
	cmp     #$00
;
; return;
;
	jeq     L000E
;
; strcpy(imgname, tmp);
;
L000F:	lda     #<(_imgname)
	ldx     #>(_imgname)
	jsr     pushax
	lda     M0001
	ldx     M0001+1
	jsr     _strcpy
;
; free(tmp);
;
	lda     M0001
	ldx     M0001+1
	jsr     _free
;
; } else {
;
	jmp     L0005
;
; strcpy(imgname, filename);
;
L0002:	lda     #<(_imgname)
	ldx     #>(_imgname)
	jsr     pushax
	ldy     #$0B
	jsr     ldaxysp
	jsr     _strcpy
;
; if (imgname[0]) {
;
L0005:	lda     _imgname
	jeq     L000E
;
; int fd = open(imgname, O_RDONLY);
;
	lda     #<(_imgname)
	ldx     #>(_imgname)
	jsr     pushax
	lda     #$01
	jsr     pusha0
	ldy     #$04
	jsr     _open
	sta     M0002
	stx     M0002+1
;
; if (fd > 0) {
;
	cmp     #$01
	txa
	sbc     #$00
	bvs     L0008
	eor     #$80
L0008:	bpl     L0007
;
; read(fd, magic, 4);
;
	lda     M0002
	ldx     M0002+1
	jsr     pushax
	lda     #<(_magic)
	ldx     #>(_magic)
	jsr     pushax
	ldx     #$00
	lda     #$04
	jsr     _read
;
; magic[4] = '\0';
;
	lda     #$00
	sta     _magic+4
;
; close(fd);
;
	lda     M0002
	ldx     M0002+1
	jsr     _close
;
; reopen_start_device();
;
L0007:	jsr     _reopen_start_device
;
; snprintf(args, FILENAME_MAX + FOUR_NUM_WIDTH - 1, "%s %d %d %d %d", imgname, sx, sy, ex, ey);
;
	lda     #<(_args)
	ldx     #>(_args)
	jsr     pushax
	lda     #$50
	jsr     pusha0
	lda     #<(S0044)
	ldx     #>(S0044)
	jsr     pushax
	lda     #<(_imgname)
	ldx     #>(_imgname)
	jsr     pushax
	ldy     #$11
	jsr     pushwysp
	ldy     #$11
	jsr     pushwysp
	ldy     #$11
	jsr     pushwysp
	ldy     #$11
	jsr     pushwysp
	ldy     #$10
	jsr     _snprintf
;
; if (!strcmp(magic, QTKT_MAGIC)) {
;
	lda     #<(_magic)
	ldx     #>(_magic)
	jsr     pushax
	lda     #<(S0045)
	ldx     #>(S0045)
	jsr     _strcmp
	stx     tmp1
	ora     tmp1
	bne     L0009
;
; exec("qtktconv", args);
;
	lda     #<(S0046)
	ldx     #>(S0046)
	jsr     pushax
	lda     #<(_args)
	ldx     #>(_args)
	jsr     _exec
;
; } else if (!strcmp(magic, QTKN_MAGIC)) {
;
	jmp     L000E
L0009:	lda     #<(_magic)
	ldx     #>(_magic)
	jsr     pushax
	lda     #<(S0047)
	ldx     #>(S0047)
	jsr     _strcmp
	stx     tmp1
	ora     tmp1
	bne     L000B
;
; exec("qtknconv", args);
;
	lda     #<(S0048)
	ldx     #>(S0048)
	jsr     pushax
	lda     #<(_args)
	ldx     #>(_args)
	jsr     _exec
;
; } else if (!strcmp(magic, JPEG_EXIF_MAGIC)) {
;
	jmp     L000E
L000B:	lda     #<(_magic)
	ldx     #>(_magic)
	jsr     pushax
	lda     #<(S0049)
	ldx     #>(S0049)
	jsr     _strcmp
	stx     tmp1
	ora     tmp1
	bne     L000D
;
; exec("jpegconv", args);
;
	lda     #<(S004A)
	ldx     #>(S004A)
	jsr     pushax
	lda     #<(_args)
	ldx     #>(_args)
	jsr     _exec
;
; } else {
;
	jmp     L000E
;
; cputs("\r\nUnknown file type.\r\n");
;
L000D:	lda     #<(S004B)
	ldx     #>(S004B)
	jsr     _cputs
;
; cgetc();
;
	jsr     _cgetc
;
; }
;
L000E:	ldy     #$0A
	jmp     addysp

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ histogram_equalize (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_histogram_equalize: near

.segment	"CODE"

;
; uint16 curr_hist = 0;
;
	lda     #$00
	sta     M0001
	sta     M0001+1
;
; if (auto_level) {
;
	lda     _auto_level
	jeq     L0002
;
; ifd = open(HIST_NAME, O_RDONLY);
;
	lda     #<(S004C)
	ldx     #>(S004C)
	jsr     pushax
	lda     #$01
	jsr     pusha0
	ldy     #$04
	jsr     _open
	sta     _ifd
	stx     _ifd+1
;
; if (ifd <= 0) {
;
	cmp     #$01
	txa
	sbc     #$00
	bvc     L0004
	eor     #$80
;
; goto fallback_std;
;
L0004:	jmi     L0002
;
; if (read(ifd, err_buf, 256) < 256 ||
;
	lda     _ifd
	ldx     _ifd+1
	jsr     pushax
	lda     #<(_err_buf)
	ldx     #>(_err_buf)
	jsr     pushax
	ldx     #$01
	lda     #$00
	jsr     _read
	cmp     #$00
	txa
	sbc     #$01
	bvc     L0007
	eor     #$80
L0007:	bmi     L0002
;
; read(ifd, err_buf+256, 256)) {
;
	lda     _ifd
	ldx     _ifd+1
	jsr     pushax
	lda     #<(_err_buf+256)
	ldx     #>(_err_buf+256)
	jsr     pushax
	ldx     #$01
	lda     #$00
	jsr     _read
	stx     tmp1
	ora     tmp1
	bne     L0002
;
; close(ifd);
;
	lda     _ifd
	ldx     _ifd+1
	jsr     _close
;
; cputs("Histogram equalization...\r\n");
;
	lda     #<(S004D)
	ldx     #>(S004D)
	jsr     _cputs
;
; __asm__("ldy #0");
;
	ldy     #0
;
; __asm__("clc");
;
L000A:	clc
;
; __asm__("lda %v,y", err_buf);
;
	lda     _err_buf,y
;
; __asm__("adc %v", curr_hist);
;
	adc     M0001
;
; __asm__("sta %v", curr_hist);
;
	sta     M0001
;
; __asm__("tax"); /* *256 */
;
	tax
;
; __asm__("lda %v+256,y", err_buf);
;
	lda     _err_buf+256,y
;
; __asm__("adc %v+1", curr_hist);
;
	adc     M0001+1
;
; __asm__("sta %v+1", curr_hist);
;
	sta     M0001+1
;
; __asm__("sta sreg"); /* * 256 */
;
	sta     sreg
;
; __asm__("lda #0");
;
	lda     #0
;
; __asm__("sec");
;
	sec
;
; __asm__("sbc %v", curr_hist);
;
	sbc     M0001
;
; __asm__("txa");
;
	txa
;
; __asm__("sbc %v+1", curr_hist);
;
	sbc     M0001+1
;
; __asm__("tax");
;
	tax
;
; __asm__("lda sreg");
;
	lda     sreg
;
; __asm__("sbc #0");
;
	sbc     #0
;
; __asm__("sta sreg");
;
	sta     sreg
;
; __asm__("txa");
;
	txa
;
; __asm__("ldx sreg");
;
	ldx     sreg
;
; __asm__("sty tmp1");
;
	sty     tmp1
;
; __asm__("jsr pushax");
;
	jsr     pushax
;
; __asm__("lda #<%w", HGR_HEIGHT);
;
	lda     #<$00C0
;
; __asm__("jsr tosudiva0");
;
	jsr     tosudiva0
;
; __asm__("ldy tmp1");
;
	ldy     tmp1
;
; __asm__("sta %v,y", opt_histogram);
;
	sta     _opt_histogram,y
;
; __asm__("iny");
;
	iny
;
; __asm__("bne %g", next_h);
;
	bne     L000A
;
; } else {
;
	rts
;
; __asm__("ldy #0");
;
L0002:	ldy     #0
;
; __asm__("tya");
;
L000C:	tya
;
; __asm__("sta %v,y", opt_histogram);
;
	sta     _opt_histogram,y
;
; __asm__("iny");
;
	iny
;
; __asm__("bne %g", next_val);
;
	bne     L000C
;
; }
;
	rts

.segment	"RODATA"

M0002:
	.word	$0000
M0003:
	.word	$0000

.segment	"BSS"

M0001:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ thumb_histogram (int ifd)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_thumb_histogram: near

.segment	"CODE"

;
; static void thumb_histogram(int ifd) {
;
	jsr     pushax
;
; uint8 x = 0, r_bytes;
;
	lda     #$00
	sta     M0001
;
; uint16 curr_hist = 0;
;
	sta     M0003
	sta     M0003+1
;
; bzero(err_buf, sizeof(err_buf));
;
	lda     #<(_err_buf)
	ldx     #>(_err_buf)
	jsr     pushax
	ldx     #$04
	lda     #$08
	jsr     _bzero
;
; while ((r_bytes = read(ifd, buffer, 255)) != 0) {
;
	jmp     L0004
;
; cur_thumb_data = buffer;
;
L0002:	lda     #>(_buffer)
	sta     _zp10p+1
	lda     #<(_buffer)
	sta     _zp10p
;
; __asm__("ldy #0");
;
	ldy     #0
;
; __asm__("sty %v", x);
;
L0005:	sty     M0001
;
; __asm__("lda (%v),y", cur_thumb_data); /* read byte */
;
	lda     (_zp10p),y
;
; __asm__("tay"); /* backup it */
;
	tay
;
; __asm__("asl"); /* << 4 low nibble */
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("tax");
;
	tax
;
; __asm__("inc %v,x", err_buf);
;
	inc     _err_buf,x
;
; __asm__("bne %g", noof22);
;
	bne     L0006
;
; __asm__("inc %v+256,x", err_buf);
;
	inc     _err_buf+256,x
;
; __asm__("tya");
;
L0006:	tya
;
; __asm__("and #$F0");
;
	and     #$F0
;
; __asm__("tax");
;
	tax
;
; __asm__("inc %v,x", err_buf);
;
	inc     _err_buf,x
;
; __asm__("bne %g", noof23);
;
	bne     L0007
;
; __asm__("inc %v+256,x", err_buf);
;
	inc     _err_buf+256,x
;
; __asm__("ldy %v", x);
;
L0007:	ldy     M0001
;
; __asm__("iny");
;
	iny
;
; __asm__("cpy %v", r_bytes);
;
	cpy     M0002
;
; __asm__("bne %g", next_byte);
;
	bne     L0005
;
; while ((r_bytes = read(ifd, buffer, 255)) != 0) {
;
L0004:	jsr     pushw0sp
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	ldx     #$00
	lda     #$FF
	jsr     _read
	sta     M0002
	cmp     #$00
	bne     L0002
;
; x = 0;
;
	sta     M0001
;
; __asm__("ldx %v", x);
;
L0008:	ldx     M0001
;
; __asm__("clc");
;
	clc
;
; __asm__("lda %v,x", err_buf);
;
	lda     _err_buf,x
;
; __asm__("adc %v", curr_hist);
;
	adc     M0003
;
; __asm__("sta %v", curr_hist);
;
	sta     M0003
;
; __asm__("lda %v+256,x", err_buf);
;
	lda     _err_buf+256,x
;
; __asm__("adc %v+1", curr_hist);
;
	adc     M0003+1
;
; __asm__("sta %v+1", curr_hist);
;
	sta     M0003+1
;
; tmp_large = ((uint32)curr_hist * 0xF0);
;
	lda     M0003
	ldx     M0003+1
	jsr     axulong
	jsr     pusheax
	lda     #$00
	lda     #$F0
	ldx     #$00
	jsr     tosumul0ax
	sta     M000A
	stx     M000A+1
	ldy     sreg
	sty     M000A+2
	ldy     sreg+1
	sty     M000A+3
;
; tmp = tmp_large >> 6; /* /64 */
;
	lda     M000A+3
	sta     sreg+1
	lda     M000A+2
	sta     sreg
	ldx     M000A+1
	lda     M000A
	jsr     shreax4
	jsr     shreax2
	sta     M000B
	stx     M000B+1
;
; __A__ = tmp / 75;            /* /64/75 = /80/60 */
;
	jsr     pushax
	lda     #$4B
	jsr     tosudiva0
;
; __asm__("ldx %v", x);
;
	ldx     M0001
;
; __asm__("sta %v,x", opt_histogram);
;
	sta     _opt_histogram,x
;
; } while (x++ < 0xF0);
;
	lda     M0001
	inc     M0001
	cmp     #$F0
	bcc     L0008
;
; }
;
	jmp     incsp2

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00
M0003:
	.res	2,$00
M000A:
	.res	4,$00
M000B:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; void __near__ init_data (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init_data: near

.segment	"CODE"

;
; if (init_done) {
;
	lda     M0001
;
; return;
;
	bne     L0001
;
; init_hgr_base_addrs();
;
	jsr     _init_hgr_base_addrs
;
; histogram_equalize();
;
	jsr     _histogram_equalize
;
; init_done = 1;
;
	lda     #$01
	sta     M0001
;
; }
;
L0001:	rts

.segment	"DATA"

M0001:
	.byte	$00

.endproc

; ---------------------------------------------------------------
; void __near__ invert_selection (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_invert_selection: near

.segment	"CODE"

;
; uint16 dsx = crop_start_x * 8 / 10;
;
	lda     _crop_start_x
	ldx     _crop_start_x+1
	jsr     shlax3
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     M0004
	stx     M0004+1
;
; uint16 dex = crop_end_x * 8 / 10;
;
	lda     _crop_end_x
	ldx     _crop_end_x+1
	jsr     shlax3
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     M0005
	stx     M0005+1
;
; uint16 dsy = crop_start_y * 4 / 10;
;
	lda     _crop_start_y
	ldx     _crop_start_y+1
	jsr     shlax2
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     M0006
	stx     M0006+1
;
; uint16 dey = crop_end_y * 4 / 10;
;
	lda     _crop_end_y
	ldx     _crop_end_y+1
	jsr     shlax2
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     M0007
	stx     M0007+1
;
; dsx += 14;  /* Account for centering */
;
	lda     #$0E
	clc
	adc     M0004
	sta     M0004
	bcc     L0002
	inc     M0004+1
;
; dex += 14;
;
L0002:	lda     #$0E
	clc
	adc     M0005
	sta     M0005
	bcc     L0003
	inc     M0005+1
;
; lx = (dsx)/7;
;
L0003:	lda     M0004
	ldx     M0004+1
	jsr     pushax
	lda     #$07
	jsr     tosudiva0
	sta     M0002
	stx     M0002+1
;
; rx = (dex)/7;
;
	lda     M0005
	ldx     M0005+1
	jsr     pushax
	lda     #$07
	jsr     tosudiva0
	sta     M0003
	stx     M0003+1
;
; printf("crop %d-%d, dsx %d-%d, lx %d-%d\n",
;
	lda     #<(S0090)
	ldx     #>(S0090)
	jsr     pushax
;
; crop_start_x, crop_end_x, dsx, dex, lx, rx);
;
	lda     _crop_start_x
	ldx     _crop_start_x+1
	jsr     pushax
	lda     _crop_end_x
	ldx     _crop_end_x+1
	jsr     pushax
	lda     M0004
	ldx     M0004+1
	jsr     pushax
	lda     M0005
	ldx     M0005+1
	jsr     pushax
	lda     M0002
	ldx     M0002+1
	jsr     pushax
	lda     M0003
	ldx     M0003+1
	jsr     pushax
	ldy     #$0E
	jsr     _printf
;
; if (lx % 2 == 0) {
;
	lda     M0002
	and     #$01
	bne     L0004
;
; __asm__("sta $C055");
;
	sta     $C055
;
; } else {
;
	jmp     L0006
;
; __asm__("sta $C054");
;
L0004:	sta     $C054
;
; a = (uint8 *)(hgr_baseaddr_l[dsy]|(hgr_baseaddr_h[dsy]<<8)) + lx/2;
;
L0006:	lda     M0006
	sta     ptr1
	lda     M0006+1
	clc
	adc     #>(_hgr_baseaddr_l)
	sta     ptr1+1
	ldy     #<(_hgr_baseaddr_l)
	lda     (ptr1),y
	sta     sreg
	lda     M0006
	sta     ptr1
	lda     M0006+1
	clc
	adc     #>(_hgr_baseaddr_h)
	sta     ptr1+1
	ldy     #<(_hgr_baseaddr_h)
	lda     (ptr1),y
	tax
	lda     sreg
	sta     ptr1
	stx     ptr1+1
	lda     M0002
	ldx     M0002+1
	jsr     shrax1
	clc
	adc     ptr1
	sta     _zp8p
	txa
	adc     ptr1+1
	sta     _zp8p+1
;
; b = (uint8 *)(hgr_baseaddr_l[dey]|(hgr_baseaddr_h[dey]<<8)) + lx/2;
;
	lda     M0007
	sta     ptr1
	lda     M0007+1
	clc
	adc     #>(_hgr_baseaddr_l)
	sta     ptr1+1
	ldy     #<(_hgr_baseaddr_l)
	lda     (ptr1),y
	sta     sreg
	lda     M0007
	sta     ptr1
	lda     M0007+1
	clc
	adc     #>(_hgr_baseaddr_h)
	sta     ptr1+1
	ldy     #<(_hgr_baseaddr_h)
	lda     (ptr1),y
	tax
	lda     sreg
	sta     ptr1
	stx     ptr1+1
	lda     M0002
	ldx     M0002+1
	jsr     shrax1
	clc
	adc     ptr1
	sta     _zp10p
	txa
	adc     ptr1+1
	sta     _zp10p+1
;
; for (x = lx/2; x < rx/2; x++) {
;
	lda     M0002
	ldx     M0002+1
	jsr     shrax1
	sta     M0001
	stx     M0001+1
L0007:	lda     M0001
	ldx     M0001+1
	jsr     pushax
	lda     M0003
	ldx     M0003+1
	jsr     shrax1
	jsr     tosicmp
	bcs     L0008
;
; *a = ~(*a);
;
	ldy     #$00
	lda     (_zp8p),y
	eor     #$FF
	sta     (_zp8p),y
;
; *b = ~(*b);
;
	lda     (_zp10p),y
	eor     #$FF
	sta     (_zp10p),y
;
; a++;
;
	inc     _zp8p
	bne     L000C
	inc     _zp8p+1
;
; b++;
;
L000C:	inc     _zp10p
	bne     L0009
	inc     _zp10p+1
;
; for (x = lx/2; x < rx/2; x++) {
;
L0009:	inc     M0001
	bne     L0007
	inc     M0001+1
	jmp     L0007
;
; for (y = (dsy + 1); y < dey - 1; y++) {
;
L0008:	lda     M0006
	clc
	adc     #$01
	sta     _zp6
L0014:	lda     _zp6
	jsr     pusha0
	lda     M0007
	ldx     M0007+1
	jsr     decax1
	jsr     tosicmp
	bcs     L000F
;
; uint8 *by = (uint8 *)(hgr_baseaddr_l[y]|(hgr_baseaddr_h[y]<<8));
;
	ldy     _zp6
	ldx     _hgr_baseaddr_h,y
	ldy     _zp6
	lda     _hgr_baseaddr_l,y
	sta     M0008
	stx     M0008+1
;
; a = by + lx/2;
;
	sta     ptr1
	stx     ptr1+1
	lda     M0002
	ldx     M0002+1
	jsr     shrax1
	clc
	adc     ptr1
	sta     _zp8p
	txa
	adc     ptr1+1
	sta     _zp8p+1
;
; b = by + rx/2;
;
	lda     M0003
	ldx     M0003+1
	jsr     shrax1
	clc
	adc     M0008
	sta     _zp10p
	txa
	adc     M0008+1
	sta     _zp10p+1
;
; *a = ~(*a);
;
	ldy     #$00
	lda     (_zp8p),y
	eor     #$FF
	sta     (_zp8p),y
;
; *b = ~(*b);
;
	lda     (_zp10p),y
	eor     #$FF
	sta     (_zp10p),y
;
; for (y = (dsy + 1); y < dey - 1; y++) {
;
	inc     _zp6
	jmp     L0014
;
; __asm__("sta $C054");
;
L000F:	sta     $C054
;
; }
;
	rts

.segment	"BSS"

M0001:
	.res	2,$00
M0002:
	.res	2,$00
M0003:
	.res	2,$00
M0004:
	.res	2,$00
M0005:
	.res	2,$00
M0006:
	.res	2,$00
M0007:
	.res	2,$00
M0008:
	.res	2,$00

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ write_hgr_page_to_file (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_write_hgr_page_to_file: near

.segment	"CODE"

;
; return (write(ofd, (char *)HGR_PAGE, HGR_LEN) < HGR_LEN);
;
	lda     _ofd
	ldx     _ofd+1
	jsr     pushax
	ldx     #$20
	lda     #$00
	jsr     pushax
	jsr     _write
	cpx     #$20
	jmp     boolult

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ reedit_image (const char *ofname, unsigned int src_width)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_reedit_image: near

.segment	"CODE"

;
; static uint8 reedit_image(const char *ofname, uint16 src_width) {
;
	jsr     pushax
;
; clrscr();
;
L0002:	jsr     _clrscr
;
; cputs("Rotate: L:left - U:180 - R:right");
;
	lda     #<(S0094)
	ldx     #>(S0094)
	jsr     _cputs
;
; if (angle == 90 || angle == 270) {
;
	lda     _angle+1
	bne     L0099
	lda     _angle
	cmp     #$5A
	beq     L0008
L0099:	lda     _angle+1
	cmp     #$01
	bne     L0006
	lda     _angle
	cmp     #$0E
	bne     L0006
;
; if (resize)
;
L0008:	lda     _resize
	beq     L000B
;
; cputs("; C: Crop");
;
	lda     #<(S0095)
	ldx     #>(S0095)
;
; else
;
	jmp     L007F
;
; cputs("; C: Fit - Up/down: Adjust crop");
;
L000B:	lda     #<(S0096)
	ldx     #>(S0096)
;
; } else if (angle == 0 && !(src_width % 320)) {
;
	jmp     L007F
L0006:	lda     _angle
	ora     _angle+1
	bne     L000E
	jsr     pushw0sp
	ldx     #$01
	lda     #$40
	jsr     tosumodax
	stx     tmp1
	ora     tmp1
	bne     L000E
;
; cputs("; C: Reframe");
;
	lda     #<(S0097)
	ldx     #>(S0097)
L007F:	jsr     _cputs
;
; printf("\nH: Auto-level %s; B: Brighten - D: Darken (Current %s%d)\n",
;
L000E:	lda     #<(S0098)
	ldx     #>(S0098)
	jsr     pushax
;
; auto_level ? "off":"on",
;
	lda     _auto_level
	beq     L0013
	lda     #<(S0099)
	ldx     #>(S0099)
	jmp     L0014
L0013:	lda     #<(S009A)
	ldx     #>(S009A)
L0014:	jsr     pushax
;
; brighten > 0 ? "+":"",
;
	lda     _brighten
	sec
	sbc     #$01
	bvs     L0016
	eor     #$80
L0016:	bpl     L0017
	lda     #<(S009B)
	ldx     #>(S009B)
	jmp     L0018
L0017:	lda     #<(S009C)
	ldx     #>(S009C)
L0018:	jsr     pushax
;
; brighten);
;
	ldx     #$00
	lda     _brighten
	bpl     L0019
	dex
L0019:	jsr     pushax
	ldy     #$08
	jsr     _printf
;
; "S: Save - Escape: Exit - Any other key: Hide help",
;
	lda     #<(S009D)
	ldx     #>(S009D)
	jsr     pushax
;
; dither_alg == DITHER_BAYER ? "Bayer"
;
	lda     _dither_alg
	cmp     #$01
	bne     L0083
;
; : dither_alg == DITHER_SIERRA ? "Sierra Lite" : "None");
;
	lda     #<(S009F)
	ldx     #>(S009F)
	jmp     L001D
L0083:	lda     _dither_alg
	bne     L001C
	lda     #<(S00A0)
	ldx     #>(S00A0)
	jmp     L001D
L001C:	lda     #<(S00A1)
	ldx     #>(S00A1)
L001D:	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; c = tolower(cgetc());
;
	jsr     _cgetc
	jsr     _tolower
	sta     M0001
;
; if (!cropping) {
;
	lda     _cropping
	jne     L001E
;
; switch(c) {
;
	tax
	lda     M0001
;
; }
;
	cmp     #$0A
	jeq     L008D
	cmp     #$0B
	jeq     L008C
	cmp     #$1B
	beq     L0021
	cmp     #$62
	jeq     L0088
	cmp     #$63
	jeq     L002D
	cmp     #$64
	jeq     L008A
	cmp     #$65
	jeq     L0086
	cmp     #$68
	beq     L002C
	cmp     #$6C
	beq     L0028
	cmp     #$6E
	jeq     L0087
	cmp     #$72
	beq     L0026
	cmp     #$73
	beq     L0024
	cmp     #$75
	beq     L002A
	cmp     #$79
	jeq     L0085
	jmp     L0040
;
; clrscr();
;
L0021:	jsr     _clrscr
;
; hgr_mixon();
;
	jsr     _hgr_mixon
;
; cputs("Exit without saving? (y/N)");
;
	lda     #<(S00A2)
	ldx     #>(S00A2)
	jsr     _cputs
;
; c = tolower(cgetc());
;
	jsr     _cgetc
	jsr     _tolower
	sta     M0001
;
; if (c == 'y')
;
	cmp     #$79
;
; goto done;
;
	jmp     L009C
;
; clrscr();
;
L0024:	jsr     _clrscr
;
; goto save;
;
	jmp     L0004
;
; angle += 90;
;
L0026:	lda     #$5A
	clc
	adc     _angle
	sta     _angle
	bcc     L0027
	inc     _angle+1
;
; return 1;
;
L0027:	lda     #$01
	jmp     incsp4
;
; angle -= 90;
;
L0028:	lda     _angle
	sec
	sbc     #$5A
	sta     _angle
	bcs     L0029
	dec     _angle+1
;
; return 1;
;
L0029:	lda     #$01
	jmp     incsp4
;
; angle += 180;
;
L002A:	lda     #$B4
	clc
	adc     _angle
	sta     _angle
	bcc     L002B
	inc     _angle+1
;
; return 1;
;
L002B:	lda     #$01
	jmp     incsp4
;
; auto_level = !auto_level;
;
L002C:	lda     _auto_level
	jsr     bnega
	sta     _auto_level
;
; histogram_equalize();
;
	jsr     _histogram_equalize
;
; return 1;
;
	ldx     #$00
	lda     #$01
	jmp     incsp4
;
; if (angle == 0 && !(src_width % 320)) {
;
L002D:	lda     _angle
	ora     _angle+1
	bne     L002E
	jsr     pushw0sp
	ldx     #$01
	lda     #$40
	jsr     tosumodax
	stx     tmp1
	ora     tmp1
	bne     L002E
;
; cropping = 1;
;
	lda     #$01
	sta     _cropping
;
; goto crop_again;
;
	jmp     L001E
;
; resize = !resize;
;
L002E:	lda     _resize
	jsr     bnega
	sta     _resize
;
; return 1;
;
	ldx     #$00
	lda     #$01
	jmp     incsp4
;
; dither_alg = DITHER_BAYER;
;
L0085:	lda     #$01
	sta     _dither_alg
;
; return 1;
;
	jmp     incsp4
;
; dither_alg = DITHER_SIERRA;
;
L0086:	stx     _dither_alg
;
; return 1;
;
	lda     #$01
	jmp     incsp4
;
; dither_alg = DITHER_NONE;
;
L0087:	lda     #$02
	sta     _dither_alg
;
; return 1;
;
	lda     #$01
	jmp     incsp4
;
; brighten += 16;
;
L0088:	lda     #$10
	clc
	adc     _brighten
	sta     _brighten
;
; return 1;
;
	lda     #$01
	jmp     incsp4
;
; brighten -= 16;
;
L008A:	lda     _brighten
	sec
	sbc     #$10
	sta     _brighten
;
; return 1;
;
	lda     #$01
	jmp     incsp4
;
; if (crop_pos > 0) {
;
L008C:	lda     _crop_pos
	jeq     L0002
;
; crop_pos--;
;
	dec     _crop_pos
;
; return 1;
;
	lda     #$01
	jmp     incsp4
;
; if (crop_pos < 2) {
;
L008D:	lda     _crop_pos
	cmp     #$02
	jcs     L0002
;
; crop_pos++;
;
	inc     _crop_pos
;
; return 1;
;
	lda     #$01
	jmp     incsp4
;
; if (hgr_mix_is_on)
;
L0040:	lda     _hgr_mix_is_on
	beq     L0041
;
; hgr_mixoff();
;
	jsr     _hgr_mixoff
;
; else
;
	jmp     L0002
;
; hgr_mixon();
;
L0041:	jsr     _hgr_mixon
;
; }
;
	jmp     L0002
;
; move_offset = src_width == 640 ? BAND_HEIGHT : BAND_HEIGHT*2;
;
L001E:	ldy     #$01
	lda     (c_sp),y
	cmp     #$02
	bne     L0045
	dey
	lda     (c_sp),y
	cmp     #$80
	bne     L0045
	lda     #$14
	jmp     L008E
L0045:	lda     #$28
L008E:	sta     M0007
;
; clrscr();
;
	jsr     _clrscr
;
; if (src_width == 640) {
;
	ldy     #$01
	lda     (c_sp),y
	cmp     #$02
	bne     L0047
	dey
	lda     (c_sp),y
	cmp     #$80
	bne     L0047
;
; cputs("+: Zoom in; -: Zoom out; ");
;
	lda     #<(S00A3)
	ldx     #>(S00A3)
	jsr     _cputs
;
; "Enter: Reframe; Escape: Cancel");
;
L0047:	lda     #<(S00A4)
	ldx     #>(S00A4)
	jsr     _cputs
;
; if (zoom_level) {
;
	lda     _zoom_level
	beq     L008F
;
; invert_selection();
;
	jsr     _invert_selection
;
; } else {
;
	jmp     L004A
;
; zoom_level = 1;
;
L008F:	lda     #$01
	sta     _zoom_level
;
; crop_start_x = crop_start_y = 0;
;
	lda     #$00
	sta     _crop_start_y
	sta     _crop_start_y+1
	sta     _crop_start_x
	sta     _crop_start_x+1
;
; crop_end_x = crop_start_x + 512;
;
	ldx     #$02
	clc
	bcc     L007C
	inx
L007C:	sta     _crop_end_x
	stx     _crop_end_x+1
;
; crop_end_y = crop_start_y + 384;
;
	lda     #$80
	clc
	adc     _crop_start_y
	sta     _crop_end_y
	lda     #$01
	adc     _crop_start_y+1
	sta     _crop_end_y+1
;
; switch(c) {
;
L004A:	lda     M0001
;
; }
;
	cmp     #$08
	jeq     L0060
	cmp     #$0A
	jeq     L0063
	cmp     #$0B
	jeq     L0066
	cmp     #$0D
	beq     L0091
	cmp     #$15
	jeq     L005D
	cmp     #$1B
	beq     L0090
	cmp     #$2B
	beq     L0092
	cmp     #$2D
	jeq     L0097
	jmp     L0069
;
; cropping = 0;
;
L0090:	lda     #$00
	sta     _cropping
;
; zoom_level = 0;
;
	sta     _zoom_level
;
; return 1;
;
	tax
	lda     #$01
	jmp     incsp4
;
; cropping = 0;
;
L0091:	lda     #$00
	sta     _cropping
;
; zoom_level = 0;
;
	sta     _zoom_level
;
; init_text();
;
	jsr     _init_text
;
; qt_convert_image_with_crop(ofname, crop_start_x, crop_start_y, crop_end_x, crop_end_y);
;
	ldy     #$05
	jsr     pushwysp
	lda     _crop_start_x
	ldx     _crop_start_x+1
	jsr     pushax
	lda     _crop_start_y
	ldx     _crop_start_y+1
	jsr     pushax
	lda     _crop_end_x
	ldx     _crop_end_x+1
	jsr     pushax
	lda     _crop_end_y
	ldx     _crop_end_y+1
	jsr     _qt_convert_image_with_crop
;
; return 1;
;
	ldx     #$00
	lda     #$01
	jmp     incsp4
;
; if (zoom_level == 1 && src_width == 640) {
;
L0092:	lda     _zoom_level
	cmp     #$01
	bne     L0096
	tay
	lda     (c_sp),y
	cmp     #$02
	bne     L0096
	dey
	lda     (c_sp),y
	cmp     #$80
	bne     L0096
;
; zoom_level = 2;
;
L0095:	lda     #$02
	sta     _zoom_level
;
; crop_start_x = crop_start_y = 0;
;
	lda     #$00
	sta     _crop_start_y
	sta     _crop_start_y+1
	sta     _crop_start_x
	sta     _crop_start_x+1
;
; crop_end_x = crop_start_x + 320;
;
	ldx     #$01
	lda     #$40
	clc
	bcc     L007D
	inx
L007D:	sta     _crop_end_x
	stx     _crop_end_x+1
;
; crop_end_y = crop_start_y + 240;
;
	lda     _crop_start_y
	ldx     _crop_start_y+1
	ldy     #$F0
	jsr     incaxy
	sta     _crop_end_y
	stx     _crop_end_y+1
;
; } else if (zoom_level == 2) {
;
	jmp     L004D
L0096:	lda     _zoom_level
	cmp     #$02
	jne     L004D
;
; zoom_level = 3;
;
	lda     #$03
	sta     _zoom_level
;
; crop_start_x = crop_start_y = 0;
;
	lda     #$00
	sta     _crop_start_y
	sta     _crop_start_y+1
	sta     _crop_start_x
	sta     _crop_start_x+1
;
; crop_end_x = crop_start_x + 256;
;
	ldx     #$01
	clc
	bcc     L007E
	inx
L007E:	sta     _crop_end_x
	stx     _crop_end_x+1
;
; crop_end_y = crop_start_y + 192;
;
	lda     _crop_start_y
	ldx     _crop_start_y+1
	ldy     #$C0
	jsr     incaxy
	sta     _crop_end_y
	stx     _crop_end_y+1
;
; break;
;
	jmp     L004D
;
; if (zoom_level == 3)
;
L0097:	lda     _zoom_level
	cmp     #$03
;
; goto zoom_level_2;
;
	beq     L0095
;
; else if (zoom_level == 2)
;
	cmp     #$02
	jne     L004D
;
; goto zoom_level_1;
;
	jmp     L008F
;
; if (crop_end_x + move_offset <= 640) {
;
L005D:	lda     _crop_end_x
	ldx     _crop_end_x+1
	clc
	adc     M0007
	bcc     L007B
	inx
L007B:	cpx     #$02
	bne     L005F
	cmp     #$81
L005F:	jcs     L004D
;
; crop_start_x += move_offset;
;
	lda     M0007
	clc
	adc     _crop_start_x
	sta     _crop_start_x
	lda     #$00
	adc     _crop_start_x+1
	sta     _crop_start_x+1
;
; crop_end_x += move_offset;
;
	lda     M0007
	clc
	adc     _crop_end_x
	sta     _crop_end_x
	lda     #$00
	adc     _crop_end_x+1
	sta     _crop_end_x+1
;
; break;
;
	jmp     L004D
;
; if (crop_start_x > 0) {
;
L0060:	lda     _crop_start_x
	ora     _crop_start_x+1
	jeq     L004D
;
; crop_start_x -= move_offset;
;
	lda     M0007
	eor     #$FF
	sec
	adc     _crop_start_x
	sta     _crop_start_x
	lda     #$FF
	adc     _crop_start_x+1
	sta     _crop_start_x+1
;
; crop_end_x -= move_offset;
;
	lda     M0007
	eor     #$FF
	sec
	adc     _crop_end_x
	sta     _crop_end_x
	lda     #$FF
	adc     _crop_end_x+1
	sta     _crop_end_x+1
;
; break;
;
	jmp     L004D
;
; if (crop_end_y < 480) {
;
L0063:	lda     _crop_end_y+1
	cmp     #$01
	bne     L0065
	lda     _crop_end_y
	cmp     #$E0
L0065:	bcs     L004D
;
; crop_start_y += move_offset;
;
	lda     M0007
	clc
	adc     _crop_start_y
	sta     _crop_start_y
	lda     #$00
	adc     _crop_start_y+1
	sta     _crop_start_y+1
;
; crop_end_y += move_offset;
;
	lda     M0007
	clc
	adc     _crop_end_y
	sta     _crop_end_y
	lda     #$00
	adc     _crop_end_y+1
	sta     _crop_end_y+1
;
; break;
;
	jmp     L004D
;
; if (crop_start_y > 0) {
;
L0066:	lda     _crop_start_y
	ora     _crop_start_y+1
	beq     L004D
;
; crop_start_y -= move_offset;
;
	lda     M0007
	eor     #$FF
	sec
	adc     _crop_start_y
	sta     _crop_start_y
	lda     #$FF
	adc     _crop_start_y+1
	sta     _crop_start_y+1
;
; crop_end_y -= move_offset;
;
	lda     M0007
	eor     #$FF
	sec
	adc     _crop_end_y
	sta     _crop_end_y
	lda     #$FF
	adc     _crop_end_y+1
	sta     _crop_end_y+1
;
; break;
;
	jmp     L004D
;
; hgr_mixon();
;
L0069:	jsr     _hgr_mixon
;
; invert_selection();
;
L004D:	jsr     _invert_selection
;
; c = cgetc();
;
	jsr     _cgetc
	sta     M0001
;
; goto crop_again;
;
	jmp     L001E
;
; strcpy((char *)buffer, ofname);
;
L0004:	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	ldy     #$05
	jsr     ldaxysp
	jsr     _strcpy
;
; if ((cp = strrchr ((char *)buffer, '.')))
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	ldx     #$00
	lda     #$2E
	jsr     _strrchr
	sta     M0002
	stx     M0002+1
	ora     M0002+1
	beq     L006A
;
; *cp = 0;
;
	lda     M0002+1
	sta     ptr1+1
	lda     M0002
	sta     ptr1
	lda     #$00
	tay
	sta     (ptr1),y
;
; if (is_horiz) {
;
L006A:	lda     _is_horiz
	beq     L006B
;
; strcat ((char *)buffer, ".dhgr");
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	lda     #<(S00A6)
	ldx     #>(S00A6)
;
; } else {
;
	jmp     L0080
;
; strcat ((char *)buffer, ".hgr");
;
L006B:	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	lda     #<(S00A7)
	ldx     #>(S00A7)
L0080:	jsr     _strcat
;
; hgr_mixon();
;
	jsr     _hgr_mixon
;
; cputs("Save to: ");
;
	lda     #<(S00A8)
	ldx     #>(S00A8)
	jsr     _cputs
;
; dget_text_single((char *)buffer, 63, NULL);
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	lda     #$3F
	jsr     pusha0
	lda     #$00
	jsr     _dget_text_single
;
; if (buffer[0] == '\0') {
;
	lda     _buffer
;
; goto start_edit;
;
L009D:	jeq     L0002
;
; _filetype = PRODOS_T_FOT;
;
	lda     #$08
	sta     __filetype
;
; _auxtype = HGR_PAGE;
;
	ldx     #$20
	lda     #$00
	sta     __auxtype
	stx     __auxtype+1
;
; if (!is_horiz) {
;
	lda     _is_horiz
	bne     L006F
;
; ((char *)HGR_PAGE)[0x78] = 0; // Black and white, 280x192
;
	sta     $2078
;
; ofd = open((char *)buffer, O_RDWR|O_CREAT);
;
L006F:	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	lda     #$13
	jsr     pusha0
	ldy     #$04
	jsr     _open
	sta     _ofd
	stx     _ofd+1
;
; if (ofd <= 0) {
;
	cmp     #$01
	txa
	sbc     #$00
	bvc     L0071
	eor     #$80
L0071:	bpl     L0070
;
; printf("Please insert image floppy for %s, or Escape to return\n", (char *)buffer);
;
	lda     #<(S00A9)
	ldx     #>(S00A9)
	jsr     pushax
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; if (cgetc() != CH_ESC)
;
	jsr     _cgetc
	cmp     #$1B
;
; goto open_again;
;
	jmp     L009D
;
; printf("Saving...");
;
L0070:	lda     #<(S00AA)
	ldx     #>(S00AA)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (is_horiz) {
;
	lda     _is_horiz
	beq     L0073
;
; backup_screen_holes(0x54);  /* Sets page 2 */
;
	lda     #$54
	jsr     _backup_screen_holes
;
; if (write_hgr_page_to_file() != 0) {
;
	jsr     _write_hgr_page_to_file
	cmp     #$00
	beq     L0074
;
; backup_screen_holes(0x55); /* Sets page 1 */
;
	lda     #$55
	jsr     _backup_screen_holes
;
; goto write_error;
;
	jmp     L0075
;
; backup_screen_holes(0x55); /* Sets page 1 */
;
L0074:	lda     #$55
	jsr     _backup_screen_holes
;
; ((char *)HGR_PAGE)[0x78] = 2; // Black and white, 560x192
;
	lda     #$02
	sta     $2078
;
; if (write_hgr_page_to_file() != 0) {
;
	jsr     _write_hgr_page_to_file
	cmp     #$00
	jsr     boolne
;
; goto write_error;
;
	jmp     L0081
;
; else if (write_hgr_page_to_file() != 0) {
;
L0073:	jsr     _write_hgr_page_to_file
	cmp     #$00
L0081:	beq     L0078
;
; printf("\nError. Press a key to continue...\n");
;
L0075:	lda     #<(S00AB)
	ldx     #>(S00AB)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; close(ofd);
;
	lda     _ofd
	ldx     _ofd+1
	jsr     _close
;
; cgetc();
;
	jsr     _cgetc
;
; goto start_edit;
;
	jmp     L0002
;
; close(ofd);
;
L0078:	lda     _ofd
	ldx     _ofd+1
	jsr     _close
;
; gotox(0);
;
	lda     #$00
	jsr     _gotox
;
; printf("Done. Go back to Edition, View, or main Menu? (E/v/m)");
;
	lda     #<(S00AC)
	ldx     #>(S00AC)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; c = tolower(cgetc());
;
	jsr     _cgetc
	jsr     _tolower
	sta     M0001
;
; if (c == 'v') {
;
	cmp     #$76
	bne     L0098
;
; state_set(STATE_EDIT, src_width, (char *)buffer);
;
	lda     #$02
	jsr     pusha
	ldy     #$04
	jsr     pushwysp
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     _state_set
;
; qt_view_image((char *)buffer);
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	jsr     _qt_view_image
;
; goto done;
;
	jmp     L007A
;
; if (c != 'm') {
;
L0098:	lda     M0001
	cmp     #$6D
;
; goto start_edit;
;
L009C:	jne     L0002
;
; hgr_mixoff();
;
L007A:	jsr     _hgr_mixoff
;
; init_text();
;
	jsr     _init_text
;
; clrscr();
;
	jsr     _clrscr
;
; return 0;
;
	ldx     #$00
	txa
;
; }
;
	jmp     incsp4

.segment	"RODATA"

M0006:
	.word	$0000
M0005:
	.word	$0000
M0013:
	.word	$0000
M0014:
	.word	$0000
M0004:
	.word	$0000
M0017:
	.word	$0000

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	2,$00
M0007:
	.res	1,$00

.endproc

; ---------------------------------------------------------------
; void __near__ load_thumbnail_data (unsigned char line)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_load_thumbnail_data: near

.segment	"CODE"

;
; void load_thumbnail_data(uint8 line) {
;
	jsr     pusha
;
; if (is_qt100) {
;
	lda     _is_qt100
	beq     L0002
;
; if (!(line & 1)) {
;
	ldy     #$00
	lda     (c_sp),y
	and     #$01
	jne     L0025
;
; read(ifd, buffer,THUMB_WIDTH / 2);
;
	jsr     decsp4
	lda     _ifd
	ldy     #$02
	sta     (c_sp),y
	iny
	lda     _ifd+1
	sta     (c_sp),y
	lda     #<(_buffer)
	ldy     #$00
	sta     (c_sp),y
	iny
	lda     #>(_buffer)
	sta     (c_sp),y
	ldx     #$00
	lda     #$28
	jsr     _read
;
; __asm__("ldy #39");
;
	ldy     #39
;
; __asm__("lda (%v),y", thumb_buf_ptr); /* Load byte at index Y */
;
L0004:	lda     (_zp2p),y
;
; __asm__("tax");       /* backup value */
;
	tax
;
; __asm__("asl");       /* low nibble, << 4 */
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("sta tmp1"); /* Store low nibble */
;
	sta     tmp1
;
; __asm__("txa");      /* Restore value */
;
	txa
;
; __asm__("and #$F0"); /* high nibble */
;
	and     #$F0
;
; __asm__("tax");      /* Store high nibble */
;
	tax
;
; __asm__("tya");      /* *4 offset */
;
	tya
;
; __asm__("sty tmp2"); /* Backup index */
;
	sty     tmp2
;
; __asm__("asl");
;
	asl     a
;
; __asm__("asl");
;
	asl     a
;
; __asm__("tay");
;
	tay
;
; __asm__("txa");      /* Store high nibble twice */
;
	txa
;
; __asm__("sta (%v),y", thumb_buf_ptr);
;
	sta     (_zp2p),y
;
; __asm__("iny");
;
	iny
;
; __asm__("sta (%v),y", thumb_buf_ptr);
;
	sta     (_zp2p),y
;
; __asm__("lda tmp1");/* Store low nibble twice */
;
	lda     tmp1
;
; __asm__("iny");
;
	iny
;
; __asm__("sta (%v),y", thumb_buf_ptr);
;
	sta     (_zp2p),y
;
; __asm__("iny");
;
	iny
;
; __asm__("sta (%v),y", thumb_buf_ptr);
;
	sta     (_zp2p),y
;
; __asm__("ldy tmp2");  /* Restore index */
;
	ldy     tmp2
;
; __asm__("dey");
;
	dey
;
; __asm__("bpl %g", next_thumb_x);
;
	bpl     L0004
;
; } else {
;
	jmp     incsp1
;
; if (!(line % 4)) {
;
L0002:	tay
	lda     (c_sp),y
	and     #$03
	jne     L0038
;
; read(ifd, thumb_buf,THUMB_WIDTH);
;
	jsr     decsp4
	lda     _ifd
	ldy     #$02
	sta     (c_sp),y
	iny
	lda     _ifd+1
	sta     (c_sp),y
	lda     #<(_thumb_buf)
	ldy     #$00
	sta     (c_sp),y
	iny
	lda     #>(_thumb_buf)
	sta     (c_sp),y
	ldx     #$00
	lda     #$50
	jsr     _read
;
; orig_in = cur_in = thumb_buf;
;
	lda     #<(_thumb_buf)
	ldx     #>(_thumb_buf)
	sta     M0009
	stx     M0009+1
	sta     M000B
	stx     M000B+1
;
; orig_out = cur_out = buffer;
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	sta     M000A
	stx     M000A+1
	sta     M000C
	stx     M000C+1
;
; for (dx = 0; dx < THUMB_WIDTH; dx++) {
;
	lda     #$00
	sta     M0005
L002E:	lda     M0005
	cmp     #$50
	bcs     L0008
;
; c = *cur_in++;
;
	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     M0003
	inc     M0009
	bne     L002F
	inc     M0009+1
;
; a   = (c & 0xF0);
;
L002F:	lda     M0003
	and     #$F0
	sta     M0001
;
; b   = ((c & 0x0F) << 4);
;
	lda     M0003
	and     #$0F
	asl     a
	asl     a
	asl     a
	asl     a
	sta     M0002
;
; *cur_out++ = a;
;
	lda     M000A+1
	sta     ptr1+1
	lda     M000A
	sta     ptr1
	lda     M0001
	sta     (ptr1),y
	inc     M000A
	bne     L000C
	inc     M000A+1
;
; *cur_out++ = b;
;
L000C:	lda     M000A+1
	sta     ptr1+1
	lda     M000A
	sta     ptr1
	lda     M0002
	sta     (ptr1),y
	inc     M000A
	bne     L0030
	inc     M000A+1
;
; for (dx = 0; dx < THUMB_WIDTH; dx++) {
;
L0030:	inc     M0005
	jmp     L002E
;
; orig_in = cur_in = buffer;
;
L0008:	lda     #<(_buffer)
	ldx     #>(_buffer)
	sta     M0009
	stx     M0009+1
	sta     M000B
	stx     M000B+1
;
; orig_out = cur_out = thumb_buf;
;
	lda     #<(_thumb_buf)
	ldx     #>(_thumb_buf)
	sta     M000A
	stx     M000A+1
	sta     M000C
	stx     M000C+1
;
; for (i = 0; i < THUMB_WIDTH * 2; ) {
;
	lda     #$00
L003B:	sta     M0006
L0031:	lda     M0006
	cmp     #$A0
	jcs     L000F
;
; if (i < THUMB_WIDTH*3/2) {
;
	cmp     #$78
	jcs     L0034
;
; a = *cur_in++;
;
	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     M0001
	inc     M0009
	bne     L0013
	inc     M0009+1
;
; b = *cur_in++;
;
L0013:	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	lda     (ptr1),y
	sta     M0002
	inc     M0009
	bne     L0014
	inc     M0009+1
;
; c = *cur_in++;
;
L0014:	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	lda     (ptr1),y
	sta     M0003
	inc     M0009
	bne     L0015
	inc     M0009+1
;
; *(cur_out) = a;
;
L0015:	lda     M000A+1
	sta     ptr1+1
	lda     M000A
	sta     ptr1
	lda     M0001
	sta     (ptr1),y
;
; *(cur_out + THUMB_WIDTH) = c;
;
	lda     M000A+1
	sta     ptr1+1
	lda     M000A
	sta     ptr1
	ldy     #$50
	lda     M0003
	sta     (ptr1),y
;
; cur_out++;
;
	inc     M000A
	bne     L0017
	inc     M000A+1
;
; *(cur_out) = b;
;
L0017:	lda     M000A+1
	sta     ptr1+1
	lda     M000A
	sta     ptr1
	lda     M0002
	ldy     #$00
	sta     (ptr1),y
;
; cur_out++;
;
	inc     M000A
	bne     L0033
	inc     M000A+1
;
; i+=3;
;
L0033:	lda     #$03
	clc
	adc     M0006
;
; } else {
;
	jmp     L003B
;
; i++;
;
L0034:	inc     M0006
;
; cur_out++;
;
	inc     M000A
	bne     L001A
	inc     M000A+1
;
; d = *cur_in++;
;
L001A:	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     M0004
	inc     M0009
	bne     L001B
	inc     M0009+1
;
; *(cur_out) = d;
;
L001B:	lda     M000A+1
	sta     ptr1+1
	lda     M000A
	sta     ptr1
	lda     M0004
	sta     (ptr1),y
;
; cur_out++;
;
	inc     M000A
	jne     L0031
	inc     M000A+1
;
; }
;
	jmp     L0031
;
; orig_in = cur_in = thumb_buf;
;
L000F:	lda     #<(_thumb_buf)
	ldx     #>(_thumb_buf)
	sta     M0009
	stx     M0009+1
	sta     M000B
	stx     M000B+1
;
; orig_out = cur_out = buffer;
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	sta     M000A
	stx     M000A+1
	sta     M000C
	stx     M000C+1
;
; for (dx = 0; dx < THUMB_WIDTH; dx++) {
;
	lda     #$00
	sta     M0005
L0035:	lda     M0005
	cmp     #$50
	jcs     L0025
;
; *cur_out = *cur_in;
;
	lda     M000A+1
	sta     sreg+1
	lda     M000A
	sta     sreg
	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     (sreg),y
;
; cur_out++;
;
	inc     M000A
	bne     L0021
	inc     M000A+1
;
; *cur_out = *cur_in;
;
L0021:	lda     M000A+1
	sta     sreg+1
	lda     M000A
	sta     sreg
	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	lda     (ptr1),y
	sta     (sreg),y
;
; cur_out++;
;
	inc     M000A
	bne     L0022
	inc     M000A+1
;
; cur_in++;
;
L0022:	inc     M0009
	bne     L0036
	inc     M0009+1
;
; for (dx = 0; dx < THUMB_WIDTH; dx++) {
;
L0036:	inc     M0005
	jmp     L0035
;
; } else if (!(line % 2)) {
;
L0038:	lda     (c_sp),y
	and     #$01
	bne     L0025
;
; orig_in = cur_in = thumb_buf + THUMB_WIDTH;
;
	lda     #<(_thumb_buf+80)
	ldx     #>(_thumb_buf+80)
	sta     M0009
	stx     M0009+1
	sta     M000B
	stx     M000B+1
;
; orig_out = cur_out = buffer;
;
	lda     #<(_buffer)
	ldx     #>(_buffer)
	sta     M000A
	stx     M000A+1
	sta     M000C
	stx     M000C+1
;
; for (dx = 0; dx < THUMB_WIDTH; dx++) {
;
	sty     M0005
L0039:	lda     M0005
	cmp     #$50
	bcs     L0025
;
; *cur_out = *cur_in;
;
	lda     M000A+1
	sta     sreg+1
	lda     M000A
	sta     sreg
	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	lda     (ptr1),y
	sta     (sreg),y
;
; cur_out++;
;
	inc     M000A
	bne     L002A
	inc     M000A+1
;
; *cur_out = *cur_in;
;
L002A:	lda     M000A+1
	sta     sreg+1
	lda     M000A
	sta     sreg
	lda     M0009+1
	sta     ptr1+1
	lda     M0009
	sta     ptr1
	lda     (ptr1),y
	sta     (sreg),y
;
; cur_out++;
;
	inc     M000A
	bne     L002B
	inc     M000A+1
;
; cur_in++;
;
L002B:	inc     M0009
	bne     L003A
	inc     M0009+1
;
; for (dx = 0; dx < THUMB_WIDTH; dx++) {
;
L003A:	inc     M0005
	jmp     L0039
;
; }
;
L0025:	jmp     incsp1

.segment	"BSS"

M0001:
	.res	1,$00
M0002:
	.res	1,$00
M0003:
	.res	1,$00
M0004:
	.res	1,$00
M0005:
	.res	1,$00
M0006:
	.res	1,$00
M0009:
	.res	2,$00
M000A:
	.res	2,$00
M000B:
	.res	2,$00
M000C:
	.res	2,$00

.endproc

