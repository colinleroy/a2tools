Bare minimum for part 1 is one string, three ints, one single-dimensional array:
- the current line
- the current depth
- the total of fitting sums
- the current directory's sum
- the current sums of depths 1 to current

Bare minimum for part 2 is two more ints:
- the minimum size needed to free enough
- the current minimum size found

I added a second string array to store the current directory hierarchy names
(not path), but in fact, nobody cares about files and directories names.

If the operator were to go back to previously listed directories and relist 
them, this algorithm wouldn't fit as it would count directories multiple times.

Algorithm:

set depth to zero, sums to zero

- for part two, 
  - init smallest fitting sum to total size
  - calculate how much we need to free

- each time we read a line
  - if it's empty, exit directory
  - if if starts with $, handle command
  - otherwise, handle file

- handle command:
  - if it's "ls", ignore, go and read the next line
  - otherwise it's a "cd"
    - if it's "..", exit directory
    - otherwise, enter directory

- enter directory:
  - increase depth
  - set current depth's sum to 0
  - go read next line

- exit directory:
  - if depth is greater than 1, increase parent's sum by current sum
  - do the exercise
  - decrease depth
  - if depth is zero, show result and end
  - otherwise, go read next line

- handle file:
  - if the first field is "dir", ignore, go and read the next line
  - otherwise, add file size to current sum
  - go read the next line

- do the exercise
  - part 1: if the current sum is under the threshold, add it to total
  - part 2: if the current sum can free enough space, 
    - and smaller than the previously saved smallest sum,
      - save this sum as smallest

- show result and end:
  - print the value

(note: we'll compare first chars instead of strings to match "ls", "dir", 
and "..")
